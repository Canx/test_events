/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./node_modules/xstate/es/Actor.js":
/*!*****************************************!*\
  !*** ./node_modules/xstate/es/Actor.js ***!
  \*****************************************/
/*! exports provided: isActor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isActor\", function() { return isActor; });\nfunction isActor(item) {\n    try {\n        return typeof item.send === 'function';\n    } catch (e) {\n        return false;\n    }\n}\n//# sourceMappingURL=Actor.js.map\n\n//# sourceURL=webpack:///./node_modules/xstate/es/Actor.js?");

/***/ }),

/***/ "./node_modules/xstate/es/Machine.js":
/*!*******************************************!*\
  !*** ./node_modules/xstate/es/Machine.js ***!
  \*******************************************/
/*! exports provided: Machine */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Machine\", function() { return Machine; });\n/* harmony import */ var _StateNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./StateNode */ \"./node_modules/xstate/es/StateNode.js\");\n\nfunction Machine(config, options, initialContext) {\n    if (initialContext === void 0) {\n        initialContext = config.context;\n    }\n    return new _StateNode__WEBPACK_IMPORTED_MODULE_0__[\"StateNode\"](config, options, initialContext);\n}\n//# sourceMappingURL=Machine.js.map\n\n//# sourceURL=webpack:///./node_modules/xstate/es/Machine.js?");

/***/ }),

/***/ "./node_modules/xstate/es/State.js":
/*!*****************************************!*\
  !*** ./node_modules/xstate/es/State.js ***!
  \*****************************************/
/*! exports provided: stateValuesEqual, State */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stateValuesEqual\", function() { return stateValuesEqual; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"State\", function() { return State; });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./node_modules/xstate/es/types.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ \"./node_modules/xstate/es/constants.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./node_modules/xstate/es/utils.js\");\nvar __read = undefined && undefined.__read || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o),\n        r,\n        ar = [],\n        e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    } catch (error) {\n        e = { error: error };\n    } finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        } finally {\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n};\nvar __spread = undefined && undefined.__spread || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\n\n\n\nfunction stateValuesEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (a === undefined || b === undefined) {\n        return false;\n    }\n    if (Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"isString\"])(a) || Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"isString\"])(b)) {\n        return a === b;\n    }\n    var aKeys = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"keys\"])(a);\n    var bKeys = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"keys\"])(b);\n    return aKeys.length === bKeys.length && aKeys.every(function (key) {\n        return stateValuesEqual(a[key], b[key]);\n    });\n}\nvar State = /** @class */ /*#__PURE__*/function () {\n    /**\n     * Creates a new State instance.\n     * @param value The state value\n     * @param context The extended state\n     * @param historyValue The tree representing historical values of the state nodes\n     * @param history The previous state\n     * @param actions An array of action objects to execute as side-effects\n     * @param activities A mapping of activities and whether they are started (`true`) or stopped (`false`).\n     * @param meta\n     * @param events Internal event queue. Should be empty with run-to-completion semantics.\n     * @param tree\n     */\n    function State(config) {\n        this.actions = [];\n        this.activities = _constants__WEBPACK_IMPORTED_MODULE_1__[\"EMPTY_ACTIVITY_MAP\"];\n        this.meta = {};\n        this.events = [];\n        this.value = config.value;\n        this.context = config.context;\n        this.event = config.event;\n        this.historyValue = config.historyValue;\n        this.history = config.history;\n        this.actions = config.actions || [];\n        this.activities = config.activities || _constants__WEBPACK_IMPORTED_MODULE_1__[\"EMPTY_ACTIVITY_MAP\"];\n        this.meta = config.meta || {};\n        this.events = config.events || [];\n        Object.defineProperty(this, 'tree', {\n            value: config.tree,\n            enumerable: false\n        });\n        this.matches = this.matches.bind(this);\n        this.toStrings = this.toStrings.bind(this);\n    }\n    /**\n     * Creates a new State instance for the given `stateValue` and `context`.\n     * @param stateValue\n     * @param context\n     */\n    State.from = function (stateValue, context) {\n        if (stateValue instanceof State) {\n            if (stateValue.context !== context) {\n                return new State({\n                    value: stateValue.value,\n                    context: context,\n                    event: stateValue.event,\n                    historyValue: stateValue.historyValue,\n                    history: stateValue.history,\n                    actions: [],\n                    activities: stateValue.activities,\n                    meta: {},\n                    events: [],\n                    tree: stateValue.tree\n                });\n            }\n            return stateValue;\n        }\n        var event = { type: _types__WEBPACK_IMPORTED_MODULE_0__[\"ActionTypes\"].Init };\n        return new State({\n            value: stateValue,\n            context: context,\n            event: event,\n            historyValue: undefined,\n            history: undefined,\n            actions: [],\n            activities: undefined,\n            meta: undefined,\n            events: []\n        });\n    };\n    /**\n     * Creates a new State instance for the given `config`.\n     * @param config The state config\n     */\n    State.create = function (config) {\n        return new State(config);\n    };\n    /**\n     * Creates a new `State` instance for the given `stateValue` and `context` with no actions (side-effects).\n     * @param stateValue\n     * @param context\n     */\n    State.inert = function (stateValue, context) {\n        if (stateValue instanceof State) {\n            if (!stateValue.actions.length) {\n                return stateValue;\n            }\n            var event_1 = { type: _types__WEBPACK_IMPORTED_MODULE_0__[\"ActionTypes\"].Init };\n            return new State({\n                value: stateValue.value,\n                context: context,\n                event: event_1,\n                historyValue: stateValue.historyValue,\n                history: stateValue.history,\n                activities: stateValue.activities,\n                tree: stateValue.tree\n            });\n        }\n        return State.from(stateValue, context);\n    };\n    Object.defineProperty(State.prototype, \"inert\", {\n        /**\n         * Returns a new `State` instance that is equal to this state no actions (side-effects).\n         */\n        get: function () {\n            return State.inert(this, this.context);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(State.prototype, \"nextEvents\", {\n        /**\n         * The next events that will cause a transition from the current state.\n         */\n        get: function () {\n            if (!this.tree) {\n                return [];\n            }\n            return this.tree.nextEvents;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Returns an array of all the string leaf state node paths.\n     * @param stateValue\n     * @param delimiter The character(s) that separate each subpath in the string state node path.\n     */\n    State.prototype.toStrings = function (stateValue, delimiter) {\n        var _this = this;\n        if (stateValue === void 0) {\n            stateValue = this.value;\n        }\n        if (delimiter === void 0) {\n            delimiter = '.';\n        }\n        if (Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"isString\"])(stateValue)) {\n            return [stateValue];\n        }\n        var valueKeys = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"keys\"])(stateValue);\n        return valueKeys.concat.apply(valueKeys, __spread(valueKeys.map(function (key) {\n            return _this.toStrings(stateValue[key]).map(function (s) {\n                return key + delimiter + s;\n            });\n        })));\n    };\n    /**\n     * Whether the current state value is a subset of the given parent state value.\n     * @param parentStateValue\n     */\n    State.prototype.matches = function (parentStateValue) {\n        return Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"matchesState\"])(parentStateValue, this.value);\n    };\n    return State;\n}();\n\n//# sourceMappingURL=State.js.map\n\n//# sourceURL=webpack:///./node_modules/xstate/es/State.js?");

/***/ }),

/***/ "./node_modules/xstate/es/StateNode.js":
/*!*********************************************!*\
  !*** ./node_modules/xstate/es/StateNode.js ***!
  \*********************************************/
/*! exports provided: StateNode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StateNode\", function() { return StateNode; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./node_modules/xstate/es/utils.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ \"./node_modules/xstate/es/types.js\");\n/* harmony import */ var _State__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./State */ \"./node_modules/xstate/es/State.js\");\n/* harmony import */ var _actionTypes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./actionTypes */ \"./node_modules/xstate/es/actionTypes.js\");\n/* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./actions */ \"./node_modules/xstate/es/actions.js\");\n/* harmony import */ var _StateTree__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./StateTree */ \"./node_modules/xstate/es/StateTree.js\");\n/* harmony import */ var _environment__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./environment */ \"./node_modules/xstate/es/environment.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./constants */ \"./node_modules/xstate/es/constants.js\");\n/* harmony import */ var _stateUtils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./stateUtils */ \"./node_modules/xstate/es/stateUtils.js\");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __rest = undefined && undefined.__rest || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n    return t;\n};\nvar __read = undefined && undefined.__read || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o),\n        r,\n        ar = [],\n        e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    } catch (error) {\n        e = { error: error };\n    } finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        } finally {\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n};\nvar __spread = undefined && undefined.__spread || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nvar __values = undefined && undefined.__values || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n        i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\n\n\n\n\n\n\n\n\n\n\nvar STATE_DELIMITER = '.';\nvar NULL_EVENT = '';\nvar STATE_IDENTIFIER = '#';\nvar TARGETLESS_KEY = '';\nvar EMPTY_OBJECT = {};\nvar isStateId = function (str) {\n    return str[0] === STATE_IDENTIFIER;\n};\nvar createDefaultOptions = function () {\n    return {\n        actions: {},\n        guards: {},\n        services: {},\n        activities: {},\n        delays: {},\n        updater: _utils__WEBPACK_IMPORTED_MODULE_0__[\"updateContext\"]\n    };\n};\nvar StateNode = /** @class */ /*#__PURE__*/function () {\n    function StateNode(_config, options,\n    /**\n     * The initial extended state\n     */\n    context) {\n        var _this = this;\n        this.context = context;\n        this.__xstatenode = true;\n        this.__cache = {\n            events: undefined,\n            relativeValue: new Map(),\n            initialStateValue: undefined,\n            initialState: undefined,\n            transitions: undefined\n        };\n        this.idMap = {};\n        var parent = _config.parent,\n            config = __rest(_config, [\"parent\"]);\n        this.config = config;\n        this.parent = parent;\n        this.options = __assign({}, createDefaultOptions(), options);\n        this.key = _config.key || _config.id || '(machine)';\n        this.machine = this.parent ? this.parent.machine : this;\n        this.path = this.parent ? this.parent.path.concat(this.key) : [];\n        this.delimiter = _config.delimiter || (this.parent ? this.parent.delimiter : STATE_DELIMITER);\n        this.id = _config.id || (this.machine ? __spread([this.machine.key], this.path).join(this.delimiter) : this.key);\n        this.version = this.parent ? this.parent.version : _config.version;\n        this.type = _config.type || (_config.parallel ? 'parallel' : _config.states && Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(_config.states).length ? 'compound' : _config.history ? 'history' : 'atomic');\n        if (!_environment__WEBPACK_IMPORTED_MODULE_6__[\"IS_PRODUCTION\"]) {\n            Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"warn\"])(!('parallel' in _config), \"The \\\"parallel\\\" property is deprecated and will be removed in version 4.1. \" + (_config.parallel ? \"Replace with `type: 'parallel'`\" : \"Use `type: '\" + this.type + \"'`\") + \" in the config for state node '\" + this.id + \"' instead.\");\n        }\n        this.initial = _config.initial;\n        this.order = _config.order || -1;\n        this.states = _config.states ? Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"mapValues\"])(_config.states, function (stateConfig, key, _, i) {\n            var _a;\n            var stateNode = new StateNode(__assign({}, stateConfig, { key: key, order: stateConfig.order === undefined ? i : stateConfig.order, parent: _this }));\n            Object.assign(_this.idMap, __assign((_a = {}, _a[stateNode.id] = stateNode, _a), stateNode.idMap));\n            return stateNode;\n        }) : EMPTY_OBJECT;\n        // History config\n        this.history = _config.history === true ? 'shallow' : _config.history || false;\n        this._transient = !!(_config.on && _config.on[NULL_EVENT]);\n        this.strict = !!_config.strict;\n        // TODO: deprecate (entry)\n        this.onEntry = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"toArray\"])(_config.entry || _config.onEntry).map(function (action) {\n            return Object(_actions__WEBPACK_IMPORTED_MODULE_4__[\"toActionObject\"])(action);\n        });\n        // TODO: deprecate (exit)\n        this.onExit = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"toArray\"])(_config.exit || _config.onExit).map(function (action) {\n            return Object(_actions__WEBPACK_IMPORTED_MODULE_4__[\"toActionObject\"])(action);\n        });\n        this.meta = _config.meta;\n        this.data = this.type === 'final' ? _config.data : undefined;\n        this.invoke = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"toArray\"])(_config.invoke).map(function (invokeConfig, i) {\n            var _a, _b;\n            if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isMachine\"])(invokeConfig)) {\n                (_this.parent || _this).options.services = __assign((_a = {}, _a[invokeConfig.id] = invokeConfig, _a), (_this.parent || _this).options.services);\n                return {\n                    type: _actionTypes__WEBPACK_IMPORTED_MODULE_3__[\"invoke\"],\n                    src: invokeConfig.id,\n                    id: invokeConfig.id\n                };\n            } else if (typeof invokeConfig.src !== 'string') {\n                var invokeSrc = _this.id + \":invocation[\" + i + \"]\"; // TODO: util function\n                _this.machine.options.services = __assign((_b = {}, _b[invokeSrc] = invokeConfig.src, _b), _this.machine.options.services);\n                return __assign({ type: _actionTypes__WEBPACK_IMPORTED_MODULE_3__[\"invoke\"], id: invokeSrc }, invokeConfig, { src: invokeSrc });\n            } else {\n                return __assign({}, invokeConfig, { type: _actionTypes__WEBPACK_IMPORTED_MODULE_3__[\"invoke\"], id: invokeConfig.id || invokeConfig.src, src: invokeConfig.src });\n            }\n        });\n        this.activities = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"toArray\"])(_config.activities).concat(this.invoke).map(function (activity) {\n            return Object(_actions__WEBPACK_IMPORTED_MODULE_4__[\"toActivityDefinition\"])(activity);\n        });\n        this.after = this.getDelayedTransitions();\n    }\n    /**\n     * Clones this state machine with custom options and context.\n     *\n     * @param options Options (actions, guards, activities, services) to recursively merge with the existing options.\n     * @param context Custom context (will override predefined context)\n     */\n    StateNode.prototype.withConfig = function (options, context) {\n        if (context === void 0) {\n            context = this.context;\n        }\n        var _a = this.options,\n            actions = _a.actions,\n            activities = _a.activities,\n            guards = _a.guards,\n            services = _a.services,\n            delays = _a.delays;\n        return new StateNode(this.config, {\n            actions: __assign({}, actions, options.actions),\n            activities: __assign({}, activities, options.activities),\n            guards: __assign({}, guards, options.guards),\n            services: __assign({}, services, options.services),\n            delays: __assign({}, delays, options.delays)\n        }, context);\n    };\n    /**\n     * Clones this state machine with custom context.\n     *\n     * @param context Custom context (will override predefined context, not recursive)\n     */\n    StateNode.prototype.withContext = function (context) {\n        return new StateNode(this.config, this.options, context);\n    };\n    Object.defineProperty(StateNode.prototype, \"definition\", {\n        /**\n         * The well-structured state node definition.\n         */\n        get: function () {\n            return {\n                id: this.id,\n                key: this.key,\n                version: this.version,\n                type: this.type,\n                initial: this.initial,\n                history: this.history,\n                states: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"mapValues\"])(this.states, function (state) {\n                    return state.definition;\n                }),\n                on: this.on,\n                onEntry: this.onEntry,\n                onExit: this.onExit,\n                activities: this.activities || [],\n                meta: this.meta,\n                order: this.order || -1,\n                data: this.data,\n                invoke: this.invoke\n            };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    StateNode.prototype.toJSON = function () {\n        return this.definition;\n    };\n    Object.defineProperty(StateNode.prototype, \"on\", {\n        /**\n         * The mapping of events to transitions.\n         */\n        get: function () {\n            return this.__cache.transitions || (this.__cache.transitions = this.formatTransitions(), this.__cache.transitions);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateNode.prototype, \"transitions\", {\n        /**\n         * All the transitions that can be taken from this state node.\n         */\n        get: function () {\n            var _this = this;\n            return Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"flatten\"])(Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(this.on).map(function (event) {\n                return _this.on[event];\n            }));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * All delayed transitions from the config.\n     */\n    StateNode.prototype.getDelayedTransitions = function () {\n        var _this = this;\n        if (this.after) {\n            return this.after;\n        }\n        var afterConfig = this.config.after;\n        var guards = this.machine.options.guards;\n        if (!afterConfig) {\n            return [];\n        }\n        if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isArray\"])(afterConfig)) {\n            return afterConfig.map(function (delayedTransition, i) {\n                var delay = delayedTransition.delay,\n                    target = delayedTransition.target;\n                var delayRef;\n                if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isFunction\"])(delay)) {\n                    delayRef = _this.id + \":delay[\" + i + \"]\";\n                    _this.options.delays[delayRef] = delay; // TODO: util function\n                } else {\n                    delayRef = delay;\n                }\n                var event = Object(_actions__WEBPACK_IMPORTED_MODULE_4__[\"after\"])(delayRef, _this.id);\n                _this.onEntry.push(Object(_actions__WEBPACK_IMPORTED_MODULE_4__[\"send\"])(event, { delay: delay }));\n                _this.onExit.push(Object(_actions__WEBPACK_IMPORTED_MODULE_4__[\"cancel\"])(event));\n                return __assign({ event: event }, delayedTransition, { source: _this, target: target === undefined ? undefined : Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"toArray\"])(target), cond: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"toGuard\"])(delayedTransition.cond, guards), actions: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"toArray\"])(delayedTransition.actions).map(function (action) {\n                        return Object(_actions__WEBPACK_IMPORTED_MODULE_4__[\"toActionObject\"])(action);\n                    }) });\n            });\n        }\n        var allDelayedTransitions = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"flatten\"])(Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(afterConfig).map(function (delayKey) {\n            var delayedTransition = afterConfig[delayKey];\n            var delay = isNaN(+delayKey) ? delayKey : +delayKey;\n            var event = Object(_actions__WEBPACK_IMPORTED_MODULE_4__[\"after\"])(delay, _this.id);\n            _this.onEntry.push(Object(_actions__WEBPACK_IMPORTED_MODULE_4__[\"send\"])(event, { delay: delay }));\n            _this.onExit.push(Object(_actions__WEBPACK_IMPORTED_MODULE_4__[\"cancel\"])(event));\n            if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isString\"])(delayedTransition)) {\n                return [{\n                    source: _this,\n                    target: [delayedTransition],\n                    delay: delay,\n                    event: event,\n                    actions: []\n                }];\n            }\n            var delayedTransitions = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"toArray\"])(delayedTransition);\n            return delayedTransitions.map(function (transition) {\n                return __assign({ event: event,\n                    delay: delay }, transition, { source: _this, target: transition.target === undefined ? transition.target : Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"toArray\"])(transition.target), cond: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"toGuard\"])(transition.cond, guards), actions: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"toArray\"])(transition.actions).map(function (action) {\n                        return Object(_actions__WEBPACK_IMPORTED_MODULE_4__[\"toActionObject\"])(action);\n                    }) });\n            });\n        }));\n        allDelayedTransitions.sort(function (a, b) {\n            return Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isString\"])(a) || Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isString\"])(b) ? 0 : +a.delay - +b.delay;\n        });\n        return allDelayedTransitions;\n    };\n    /**\n     * Returns the state nodes represented by the current state value.\n     *\n     * @param state The state value or State instance\n     */\n    StateNode.prototype.getStateNodes = function (state) {\n        var _this = this;\n        var _a;\n        if (!state) {\n            return [];\n        }\n        var stateValue = state instanceof _State__WEBPACK_IMPORTED_MODULE_2__[\"State\"] ? state.value : Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"toStateValue\"])(state, this.delimiter);\n        if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isString\"])(stateValue)) {\n            var initialStateValue = this.getStateNode(stateValue).initial;\n            return initialStateValue !== undefined ? this.getStateNodes((_a = {}, _a[stateValue] = initialStateValue, _a)) : [this.states[stateValue]];\n        }\n        var subStateKeys = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(stateValue);\n        var subStateNodes = subStateKeys.map(function (subStateKey) {\n            return _this.getStateNode(subStateKey);\n        });\n        return subStateNodes.concat(subStateKeys.reduce(function (allSubStateNodes, subStateKey) {\n            var subStateNode = _this.getStateNode(subStateKey).getStateNodes(stateValue[subStateKey]);\n            return allSubStateNodes.concat(subStateNode);\n        }, []));\n    };\n    /**\n     * Returns `true` if this state node explicitly handles the given event.\n     *\n     * @param event The event in question\n     */\n    StateNode.prototype.handles = function (event) {\n        var eventType = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"getEventType\"])(event);\n        return this.events.indexOf(eventType) !== -1;\n    };\n    /**\n     * Resolves the given `state` to a new `State` instance relative to this machine.\n     *\n     * This ensures that `.events` and `.nextEvents` represent the correct values.\n     *\n     * @param state The state to resolve\n     */\n    StateNode.prototype.resolveState = function (state) {\n        return new _State__WEBPACK_IMPORTED_MODULE_2__[\"State\"](__assign({}, state, { value: this.resolve(state.value), tree: this.getStateTree(state.value) }));\n    };\n    StateNode.prototype.transitionLeafNode = function (stateValue, state, eventObject) {\n        var stateNode = this.getStateNode(stateValue);\n        var next = stateNode.next(state, eventObject);\n        if (!next.tree) {\n            var _a = this.next(state, eventObject),\n                actions = _a.actions,\n                tree = _a.tree,\n                transitions = _a.transitions,\n                configuration = _a.configuration;\n            return {\n                tree: tree,\n                transitions: transitions,\n                configuration: configuration,\n                source: state,\n                actions: actions\n            };\n        }\n        return next;\n    };\n    StateNode.prototype.transitionCompoundNode = function (stateValue, state, eventObject) {\n        var subStateKeys = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(stateValue);\n        var stateNode = this.getStateNode(subStateKeys[0]);\n        var next = stateNode._transition(stateValue[subStateKeys[0]], state, eventObject);\n        if (!next.tree) {\n            var _a = this.next(state, eventObject),\n                actions = _a.actions,\n                tree = _a.tree,\n                transitions = _a.transitions,\n                configuration = _a.configuration;\n            return {\n                tree: tree,\n                transitions: transitions,\n                configuration: configuration,\n                source: state,\n                actions: actions\n            };\n        }\n        return next;\n    };\n    StateNode.prototype.transitionParallelNode = function (stateValue, state, eventObject) {\n        var e_1, _a;\n        var noTransitionKeys = [];\n        var transitionMap = {};\n        try {\n            for (var _b = __values(Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(stateValue)), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var subStateKey = _c.value;\n                var subStateValue = stateValue[subStateKey];\n                if (!subStateValue) {\n                    continue;\n                }\n                var subStateNode = this.getStateNode(subStateKey);\n                var next = subStateNode._transition(subStateValue, state, eventObject);\n                if (!next.tree) {\n                    noTransitionKeys.push(subStateKey);\n                }\n                transitionMap[subStateKey] = next;\n            }\n        } catch (e_1_1) {\n            e_1 = { error: e_1_1 };\n        } finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            } finally {\n                if (e_1) throw e_1.error;\n            }\n        }\n        var stateTransitions = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(transitionMap).map(function (key) {\n            return transitionMap[key];\n        });\n        var enabledTransitions = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"flatten\"])(stateTransitions.map(function (st) {\n            return st.transitions;\n        }));\n        var willTransition = stateTransitions.some(function (transition) {\n            return transition.tree !== undefined;\n        });\n        if (!willTransition) {\n            var _d = this.next(state, eventObject),\n                actions = _d.actions,\n                tree = _d.tree,\n                transitions = _d.transitions,\n                _configuration = _d.configuration;\n            return {\n                tree: tree,\n                transitions: transitions,\n                configuration: _configuration,\n                source: state,\n                actions: actions\n            };\n        }\n        var targetNodes = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"flatten\"])(stateTransitions.map(function (st) {\n            return st.configuration;\n        }));\n        var prevNodes = this.getStateNodes(stateValue);\n        // console.log(targetNodes.map(t => t.id));\n        // console.log([...getConfiguration(prevNodes, targetNodes)].map(c => c.id));\n        var stateValueFromConfiguration = Object(_stateUtils__WEBPACK_IMPORTED_MODULE_8__[\"getValue\"])(this.machine, Object(_stateUtils__WEBPACK_IMPORTED_MODULE_8__[\"getConfiguration\"])(prevNodes, targetNodes));\n        // console.log(sv);\n        var combinedTree = new _StateTree__WEBPACK_IMPORTED_MODULE_5__[\"StateTree\"](this.machine, stateValueFromConfiguration);\n        // const allTrees = keys(transitionMap)\n        //   .map(key => transitionMap[key].tree)\n        //   .filter(t => t !== undefined) as StateTree[];\n        // const combinedTree = allTrees.reduce((acc, t) => {\n        //   return acc.combine(t);\n        // });\n        var allPaths = combinedTree.paths;\n        var configuration = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"flatten\"])(Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(transitionMap).map(function (key) {\n            return transitionMap[key].configuration;\n        }));\n        // External transition that escapes orthogonal region\n        if (allPaths.length === 1 && !Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"matchesState\"])(Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"toStateValue\"])(this.path, this.delimiter), combinedTree.value)) {\n            return {\n                tree: combinedTree,\n                transitions: enabledTransitions,\n                configuration: configuration,\n                source: state,\n                actions: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"flatten\"])(Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(transitionMap).map(function (key) {\n                    return transitionMap[key].actions;\n                }))\n            };\n        }\n        // const allResolvedTrees = keys(transitionMap).map(key => {\n        //   const { tree } = transitionMap[key];\n        //   if (tree) {\n        //     return tree;\n        //   }\n        //   const subValue = path(this.path)(state.value)[key];\n        //   return new StateTree(this.getStateNode(key), subValue).absolute;\n        // });\n        // const finalCombinedTree = allResolvedTrees.reduce((acc, t) => {\n        //   return acc.combine(t);\n        // });\n        return {\n            tree: combinedTree,\n            transitions: enabledTransitions,\n            configuration: configuration,\n            source: state,\n            actions: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"flatten\"])(Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(transitionMap).map(function (key) {\n                return transitionMap[key].actions;\n            }))\n        };\n    };\n    StateNode.prototype._transition = function (stateValue, state, event) {\n        // leaf node\n        if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isString\"])(stateValue)) {\n            return this.transitionLeafNode(stateValue, state, event);\n        }\n        // hierarchical node\n        if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(stateValue).length === 1) {\n            return this.transitionCompoundNode(stateValue, state, event);\n        }\n        // orthogonal node\n        return this.transitionParallelNode(stateValue, state, event);\n    };\n    StateNode.prototype.next = function (state, eventObject) {\n        var _this = this;\n        var e_2, _a;\n        var eventType = eventObject.type;\n        var candidates = this.on[eventType];\n        if (!candidates || !candidates.length) {\n            return {\n                tree: undefined,\n                transitions: [],\n                configuration: [],\n                source: state,\n                actions: []\n            };\n        }\n        var actions = this._transient ? [{ type: _actionTypes__WEBPACK_IMPORTED_MODULE_3__[\"nullEvent\"] }] : [];\n        var nextStateStrings = [];\n        var selectedTransition;\n        try {\n            for (var candidates_1 = __values(candidates), candidates_1_1 = candidates_1.next(); !candidates_1_1.done; candidates_1_1 = candidates_1.next()) {\n                var candidate = candidates_1_1.value;\n                var cond = candidate.cond,\n                    stateIn = candidate.in;\n                var resolvedContext = state.context;\n                var isInState = stateIn ? Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isString\"])(stateIn) && isStateId(stateIn) ? // Check if in state by ID\n                state.matches(Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"toStateValue\"])(this.getStateNodeById(stateIn).path, this.delimiter)) : // Check if in state by relative grandparent\n                Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"matchesState\"])(Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"toStateValue\"])(stateIn, this.delimiter), Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"path\"])(this.path.slice(0, -2))(state.value)) : true;\n                var guardPassed = false;\n                try {\n                    guardPassed = !cond || this.evaluateGuard(cond, resolvedContext, eventObject, state);\n                } catch (err) {\n                    throw new Error(\"Unable to evaluate guard '\" + (cond.name || cond.type) + \"' in transition for event '\" + eventType + \"' in state node '\" + this.id + \"':\\n\" + err.message);\n                }\n                if (guardPassed && isInState) {\n                    if (candidate.target !== undefined) {\n                        nextStateStrings = candidate.target;\n                    }\n                    actions.push.apply(actions, __spread(Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"toArray\"])(candidate.actions)));\n                    selectedTransition = candidate;\n                    break;\n                }\n            }\n        } catch (e_2_1) {\n            e_2 = { error: e_2_1 };\n        } finally {\n            try {\n                if (candidates_1_1 && !candidates_1_1.done && (_a = candidates_1.return)) _a.call(candidates_1);\n            } finally {\n                if (e_2) throw e_2.error;\n            }\n        }\n        if (!nextStateStrings.length) {\n            return {\n                tree: selectedTransition && state.value // targetless transition\n                ? new _StateTree__WEBPACK_IMPORTED_MODULE_5__[\"StateTree\"](this, Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"path\"])(this.path)(state.value)).absolute : undefined,\n                transitions: [selectedTransition],\n                configuration: selectedTransition && state.value ? [this] : [],\n                source: state,\n                actions: actions\n            };\n        }\n        var nextStateNodes = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"flatten\"])(nextStateStrings.map(function (str) {\n            if (str instanceof StateNode) {\n                return str; // TODO: fix anys\n            }\n            return _this.getRelativeStateNodes(str, state.historyValue);\n        }));\n        var isInternal = !!selectedTransition.internal;\n        var reentryNodes = isInternal ? [] : Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"flatten\"])(nextStateNodes.map(function (n) {\n            return _this.nodesFromChild(n);\n        }));\n        var trees = nextStateNodes.map(function (stateNode) {\n            return stateNode.tree;\n        });\n        var combinedTree = trees.reduce(function (acc, t) {\n            return acc.combine(t);\n        });\n        reentryNodes.forEach(function (reentryNode) {\n            return combinedTree.addReentryNode(reentryNode);\n        });\n        return {\n            tree: combinedTree,\n            transitions: [selectedTransition],\n            configuration: nextStateNodes,\n            source: state,\n            actions: actions\n        };\n    };\n    Object.defineProperty(StateNode.prototype, \"tree\", {\n        /**\n         * The state tree represented by this state node.\n         */\n        get: function () {\n            var stateValue = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"toStateValue\"])(this.path, this.delimiter);\n            return new _StateTree__WEBPACK_IMPORTED_MODULE_5__[\"StateTree\"](this.machine, stateValue);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    StateNode.prototype.nodesFromChild = function (childStateNode) {\n        if (childStateNode.escapes(this)) {\n            return [];\n        }\n        var nodes = [];\n        var marker = childStateNode;\n        while (marker && marker !== this) {\n            nodes.push(marker);\n            marker = marker.parent;\n        }\n        nodes.push(this); // inclusive\n        return nodes;\n    };\n    StateNode.prototype.getStateTree = function (stateValue) {\n        return new _StateTree__WEBPACK_IMPORTED_MODULE_5__[\"StateTree\"](this, stateValue);\n    };\n    /**\n     * Whether the given state node \"escapes\" this state node. If the `stateNode` is equal to or the parent of\n     * this state node, it does not escape.\n     */\n    StateNode.prototype.escapes = function (stateNode) {\n        if (this === stateNode) {\n            return false;\n        }\n        var parent = this.parent;\n        while (parent) {\n            if (parent === stateNode) {\n                return false;\n            }\n            parent = parent.parent;\n        }\n        return true;\n    };\n    StateNode.prototype.evaluateGuard = function (guard, context, eventObject, state) {\n        var condFn;\n        var guards = this.machine.options.guards;\n        var guardMeta = {\n            state: state,\n            cond: guard\n        };\n        // TODO: do not hardcode!\n        if (guard.type === _constants__WEBPACK_IMPORTED_MODULE_7__[\"DEFAULT_GUARD_TYPE\"]) {\n            return guard.predicate(context, eventObject, guardMeta);\n        }\n        if (!guards[guard.type]) {\n            throw new Error(\"Guard '\" + guard.type + \"' is not implemented on machine '\" + this.machine.id + \"'.\");\n        }\n        condFn = guards[guard.type];\n        return condFn(context, eventObject, guardMeta);\n    };\n    StateNode.prototype.getActions = function (transition, prevState) {\n        var entryExitStates = transition.tree ? transition.tree.resolved.getEntryExitStates(prevState ? this.getStateTree(prevState.value) : undefined) : { entry: [], exit: [] };\n        var doneEvents = transition.tree ? transition.tree.getDoneEvents(new Set(entryExitStates.entry)) : [];\n        if (!transition.source) {\n            entryExitStates.exit = [];\n            // Ensure that root StateNode (machine) is entered\n            entryExitStates.entry.unshift(this);\n        }\n        var entryStates = new Set(entryExitStates.entry);\n        var exitStates = new Set(entryExitStates.exit);\n        var _a = __read([Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"flatten\"])(Array.from(entryStates).map(function (stateNode) {\n            return __spread(stateNode.activities.map(function (activity) {\n                return Object(_actions__WEBPACK_IMPORTED_MODULE_4__[\"start\"])(activity);\n            }), stateNode.onEntry);\n        })).concat(doneEvents.map(_actions__WEBPACK_IMPORTED_MODULE_4__[\"raise\"])), Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"flatten\"])(Array.from(exitStates).map(function (stateNode) {\n            return __spread(stateNode.onExit, stateNode.activities.map(function (activity) {\n                return Object(_actions__WEBPACK_IMPORTED_MODULE_4__[\"stop\"])(activity);\n            }));\n        }))], 2),\n            entryActions = _a[0],\n            exitActions = _a[1];\n        var actions = Object(_actions__WEBPACK_IMPORTED_MODULE_4__[\"toActionObjects\"])(exitActions.concat(transition.actions).concat(entryActions), this.machine.options.actions);\n        return actions;\n    };\n    /**\n     * Determines the next state given the current `state` and sent `event`.\n     *\n     * @param state The current State instance or state value\n     * @param event The event that was sent at the current state\n     * @param context The current context (extended state) of the current state\n     */\n    StateNode.prototype.transition = function (state, event, context) {\n        var currentState;\n        if (state instanceof _State__WEBPACK_IMPORTED_MODULE_2__[\"State\"]) {\n            currentState = context === undefined ? state : this.resolveState(_State__WEBPACK_IMPORTED_MODULE_2__[\"State\"].from(state, context));\n        } else {\n            var resolvedStateValue = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isString\"])(state) ? this.resolve(Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"pathToStateValue\"])(this.getResolvedPath(state))) : this.resolve(state);\n            var resolvedContext = context ? context : this.machine.context;\n            currentState = this.resolveState(_State__WEBPACK_IMPORTED_MODULE_2__[\"State\"].from(resolvedStateValue, resolvedContext));\n        }\n        var eventObject = Object(_actions__WEBPACK_IMPORTED_MODULE_4__[\"toEventObject\"])(event);\n        var eventType = eventObject.type;\n        if (this.strict) {\n            if (this.events.indexOf(eventType) === -1 && !Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isBuiltInEvent\"])(eventType)) {\n                throw new Error(\"Machine '\" + this.id + \"' does not accept event '\" + eventType + \"'\");\n            }\n        }\n        var stateTransition = this._transition(currentState.value, currentState, eventObject);\n        if (stateTransition.tree) {\n            stateTransition.tree = stateTransition.tree.resolved;\n        }\n        // const prevConfig = this.machine.getStateNodes(currentState.value);\n        // const cv = getValue(\n        //   this.machine,\n        //   getConfiguration(prevConfig, stateTransition.configuration)\n        // );\n        // if (stateTransition.tree) {\n        //   const eq = stateValuesEqual(cv, stateTransition.tree.value);\n        //   console.log(eq);\n        // }\n        // if (!eq) {\n        //   console.log('prevConfig', prevConfig.map(c => c.id));\n        //   console.log('config', [...stateTransition.configuration].map(c => c.id));\n        //   console.log(cv, stateTransition.tree!.value);\n        // }\n        return this.resolveTransition(stateTransition, currentState, eventObject);\n    };\n    StateNode.prototype.resolveTransition = function (stateTransition, currentState, _eventObject) {\n        var _this = this;\n        var e_3, _a, _b;\n        var resolvedStateValue = stateTransition.tree ? stateTransition.tree.value : undefined;\n        var historyValue = currentState ? currentState.historyValue ? currentState.historyValue : stateTransition.source ? this.machine.historyValue(currentState.value) : undefined : undefined;\n        var currentContext = currentState ? currentState.context : stateTransition.context || this.machine.context;\n        var eventObject = _eventObject || { type: _types__WEBPACK_IMPORTED_MODULE_1__[\"ActionTypes\"].Init };\n        if (!_environment__WEBPACK_IMPORTED_MODULE_6__[\"IS_PRODUCTION\"] && stateTransition.tree) {\n            try {\n                this.ensureValidPaths(stateTransition.tree.paths); // TODO: ensure code coverage for this\n            } catch (e) {\n                throw new Error(\"Event '\" + (eventObject ? eventObject.type : 'none') + \"' leads to an invalid configuration: \" + e.message);\n            }\n        }\n        var actions = this.getActions(stateTransition, currentState);\n        var activities = currentState ? __assign({}, currentState.activities) : {};\n        try {\n            for (var actions_1 = __values(actions), actions_1_1 = actions_1.next(); !actions_1_1.done; actions_1_1 = actions_1.next()) {\n                var action = actions_1_1.value;\n                if (action.type === _actionTypes__WEBPACK_IMPORTED_MODULE_3__[\"start\"]) {\n                    activities[action.activity.type] = action;\n                } else if (action.type === _actionTypes__WEBPACK_IMPORTED_MODULE_3__[\"stop\"]) {\n                    activities[action.activity.type] = false;\n                }\n            }\n        } catch (e_3_1) {\n            e_3 = { error: e_3_1 };\n        } finally {\n            try {\n                if (actions_1_1 && !actions_1_1.done && (_a = actions_1.return)) _a.call(actions_1);\n            } finally {\n                if (e_3) throw e_3.error;\n            }\n        }\n        var _c = __read(Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"partition\"])(actions, function (action) {\n            return action.type === _actionTypes__WEBPACK_IMPORTED_MODULE_3__[\"raise\"] || action.type === _actionTypes__WEBPACK_IMPORTED_MODULE_3__[\"nullEvent\"];\n        }), 2),\n            raisedEvents = _c[0],\n            otherActions = _c[1];\n        var _d = __read(Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"partition\"])(otherActions, function (action) {\n            return action.type === _actionTypes__WEBPACK_IMPORTED_MODULE_3__[\"assign\"];\n        }), 2),\n            assignActions = _d[0],\n            nonEventActions = _d[1];\n        var updatedContext = assignActions.length ? this.options.updater(currentContext, eventObject, assignActions) : currentContext;\n        var resolvedActions = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"flatten\"])(nonEventActions.map(function (actionObject) {\n            if (actionObject.type === _actionTypes__WEBPACK_IMPORTED_MODULE_3__[\"send\"]) {\n                var sendAction = Object(_actions__WEBPACK_IMPORTED_MODULE_4__[\"resolveSend\"])(actionObject, updatedContext, eventObject || { type: _types__WEBPACK_IMPORTED_MODULE_1__[\"ActionTypes\"].Init }); // TODO: fix ActionTypes.Init\n                if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isString\"])(sendAction.delay)) {\n                    if (!_this.machine.options.delays || _this.machine.options.delays[sendAction.delay] === undefined) {\n                        if (!_environment__WEBPACK_IMPORTED_MODULE_6__[\"IS_PRODUCTION\"]) {\n                            Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"warn\"])(false,\n                            // tslint:disable-next-line:max-line-length\n                            \"No delay reference for delay expression '\" + sendAction.delay + \"' was found on machine '\" + _this.machine.id + \"'\");\n                        }\n                        // Do not send anything\n                        return sendAction;\n                    }\n                    var delayExpr = _this.machine.options.delays[sendAction.delay];\n                    sendAction.delay = typeof delayExpr === 'number' ? delayExpr : delayExpr(updatedContext, eventObject || { type: _types__WEBPACK_IMPORTED_MODULE_1__[\"ActionTypes\"].Init });\n                }\n                return sendAction;\n            }\n            if (actionObject.type === _types__WEBPACK_IMPORTED_MODULE_1__[\"ActionTypes\"].Pure) {\n                return actionObject.get(updatedContext, eventObject) || [];\n            }\n            return Object(_actions__WEBPACK_IMPORTED_MODULE_4__[\"toActionObject\"])(actionObject, _this.options.actions);\n        }));\n        var stateNodes = resolvedStateValue ? this.getStateNodes(resolvedStateValue) : [];\n        var isTransient = stateNodes.some(function (stateNode) {\n            return stateNode._transient;\n        });\n        if (isTransient) {\n            raisedEvents.push({ type: _actionTypes__WEBPACK_IMPORTED_MODULE_3__[\"nullEvent\"] });\n        }\n        var meta = __spread([this], stateNodes).reduce(function (acc, stateNode) {\n            if (stateNode.meta !== undefined) {\n                acc[stateNode.id] = stateNode.meta;\n            }\n            return acc;\n        }, {});\n        var nextState = new _State__WEBPACK_IMPORTED_MODULE_2__[\"State\"]({\n            value: resolvedStateValue || currentState.value,\n            context: updatedContext,\n            event: eventObject || _actions__WEBPACK_IMPORTED_MODULE_4__[\"initEvent\"],\n            historyValue: resolvedStateValue ? historyValue ? Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"updateHistoryValue\"])(historyValue, resolvedStateValue) : undefined : currentState ? currentState.historyValue : undefined,\n            history: !resolvedStateValue || stateTransition.source ? currentState : undefined,\n            actions: resolvedStateValue ? resolvedActions : [],\n            activities: resolvedStateValue ? activities : currentState ? currentState.activities : {},\n            meta: resolvedStateValue ? meta : currentState ? currentState.meta : undefined,\n            events: resolvedStateValue ? raisedEvents : [],\n            tree: resolvedStateValue ? stateTransition.tree : currentState ? currentState.tree : undefined\n        });\n        nextState.changed = eventObject.type === _actionTypes__WEBPACK_IMPORTED_MODULE_3__[\"update\"] || !!assignActions.length;\n        // Dispose of penultimate histories to prevent memory leaks\n        var history = nextState.history;\n        if (history) {\n            delete history.history;\n        }\n        if (!resolvedStateValue) {\n            return nextState;\n        }\n        var maybeNextState = nextState;\n        while (raisedEvents.length) {\n            var currentActions = maybeNextState.actions;\n            var raisedEvent = raisedEvents.shift();\n            maybeNextState = this.transition(maybeNextState, raisedEvent.type === _actionTypes__WEBPACK_IMPORTED_MODULE_3__[\"nullEvent\"] ? NULL_EVENT : raisedEvent.event, maybeNextState.context);\n            // Save original event to state\n            maybeNextState.event = eventObject;\n            (_b = maybeNextState.actions).unshift.apply(_b, __spread(currentActions));\n        }\n        // Detect if state changed\n        var changed = maybeNextState.changed || (history ? !!maybeNextState.actions.length || !!assignActions.length || typeof history.value !== typeof maybeNextState.value || !Object(_State__WEBPACK_IMPORTED_MODULE_2__[\"stateValuesEqual\"])(maybeNextState.value, history.value) : undefined);\n        maybeNextState.changed = changed;\n        // Preserve original history after raised events\n        maybeNextState.historyValue = nextState.historyValue;\n        maybeNextState.history = history;\n        return maybeNextState;\n    };\n    StateNode.prototype.ensureValidPaths = function (paths) {\n        var _this = this;\n        var e_4, _a;\n        if (!_environment__WEBPACK_IMPORTED_MODULE_6__[\"IS_PRODUCTION\"]) {\n            var visitedParents = new Map();\n            var stateNodes = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"flatten\"])(paths.map(function (_path) {\n                return _this.getRelativeStateNodes(_path);\n            }));\n            try {\n                outer: for (var stateNodes_1 = __values(stateNodes), stateNodes_1_1 = stateNodes_1.next(); !stateNodes_1_1.done; stateNodes_1_1 = stateNodes_1.next()) {\n                    var stateNode = stateNodes_1_1.value;\n                    var marker = stateNode;\n                    while (marker.parent) {\n                        if (visitedParents.has(marker.parent)) {\n                            if (marker.parent.type === 'parallel') {\n                                continue outer;\n                            }\n                            throw new Error(\"State node '\" + stateNode.id + \"' shares parent '\" + marker.parent.id + \"' with state node '\" + visitedParents.get(marker.parent).map(function (a) {\n                                return a.id;\n                            }) + \"'\");\n                        }\n                        if (!visitedParents.get(marker.parent)) {\n                            visitedParents.set(marker.parent, [stateNode]);\n                        } else {\n                            visitedParents.get(marker.parent).push(stateNode);\n                        }\n                        marker = marker.parent;\n                    }\n                }\n            } catch (e_4_1) {\n                e_4 = { error: e_4_1 };\n            } finally {\n                try {\n                    if (stateNodes_1_1 && !stateNodes_1_1.done && (_a = stateNodes_1.return)) _a.call(stateNodes_1);\n                } finally {\n                    if (e_4) throw e_4.error;\n                }\n            }\n        } else {\n            return;\n        }\n    };\n    /**\n     * Returns the child state node from its relative `stateKey`, or throws.\n     */\n    StateNode.prototype.getStateNode = function (stateKey) {\n        if (isStateId(stateKey)) {\n            return this.machine.getStateNodeById(stateKey);\n        }\n        if (!this.states) {\n            throw new Error(\"Unable to retrieve child state '\" + stateKey + \"' from '\" + this.id + \"'; no child states exist.\");\n        }\n        var result = this.states[stateKey];\n        if (!result) {\n            throw new Error(\"Child state '\" + stateKey + \"' does not exist on '\" + this.id + \"'\");\n        }\n        return result;\n    };\n    /**\n     * Returns the state node with the given `stateId`, or throws.\n     *\n     * @param stateId The state ID. The prefix \"#\" is removed.\n     */\n    StateNode.prototype.getStateNodeById = function (stateId) {\n        var resolvedStateId = isStateId(stateId) ? stateId.slice(STATE_IDENTIFIER.length) : stateId;\n        if (resolvedStateId === this.id) {\n            return this;\n        }\n        var stateNode = this.machine.idMap[resolvedStateId];\n        if (!stateNode) {\n            throw new Error(\"Child state node '#\" + resolvedStateId + \"' does not exist on machine '\" + this.id + \"'\");\n        }\n        return stateNode;\n    };\n    /**\n     * Returns the relative state node from the given `statePath`, or throws.\n     *\n     * @param statePath The string or string array relative path to the state node.\n     */\n    StateNode.prototype.getStateNodeByPath = function (statePath) {\n        if (typeof statePath === 'string' && isStateId(statePath)) {\n            try {\n                return this.getStateNodeById(statePath.slice(1));\n            } catch (e) {\n                // try individual paths\n                // throw e;\n            }\n        }\n        var arrayStatePath = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"toStatePath\"])(statePath, this.delimiter).slice();\n        var currentStateNode = this;\n        while (arrayStatePath.length) {\n            var key = arrayStatePath.shift();\n            if (!key.length) {\n                break;\n            }\n            currentStateNode = currentStateNode.getStateNode(key);\n        }\n        return currentStateNode;\n    };\n    /**\n     * Resolves a partial state value with its full representation in this machine.\n     *\n     * @param stateValue The partial state value to resolve.\n     */\n    StateNode.prototype.resolve = function (stateValue) {\n        var _this = this;\n        var _a;\n        if (!stateValue) {\n            return this.initialStateValue || EMPTY_OBJECT; // TODO: type-specific properties\n        }\n        switch (this.type) {\n            case 'parallel':\n                return Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"mapValues\"])(this.initialStateValue, function (subStateValue, subStateKey) {\n                    return subStateValue ? _this.getStateNode(subStateKey).resolve(stateValue[subStateKey] || subStateValue) : EMPTY_OBJECT;\n                });\n            case 'compound':\n                if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isString\"])(stateValue)) {\n                    var subStateNode = this.getStateNode(stateValue);\n                    if (subStateNode.type === 'parallel' || subStateNode.type === 'compound') {\n                        return _a = {}, _a[stateValue] = subStateNode.initialStateValue, _a;\n                    }\n                    return stateValue;\n                }\n                if (!Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(stateValue).length) {\n                    return this.initialStateValue || {};\n                }\n                return Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"mapValues\"])(stateValue, function (subStateValue, subStateKey) {\n                    return subStateValue ? _this.getStateNode(subStateKey).resolve(subStateValue) : EMPTY_OBJECT;\n                });\n            default:\n                return stateValue || EMPTY_OBJECT;\n        }\n    };\n    Object.defineProperty(StateNode.prototype, \"resolvedStateValue\", {\n        get: function () {\n            var _a, _b;\n            var key = this.key;\n            if (this.type === 'parallel') {\n                return _a = {}, _a[key] = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"mapFilterValues\"])(this.states, function (stateNode) {\n                    return stateNode.resolvedStateValue[stateNode.key];\n                }, function (stateNode) {\n                    return !(stateNode.type === 'history');\n                }), _a;\n            }\n            if (this.initial === undefined) {\n                // If leaf node, value is just the state node's key\n                return key;\n            }\n            if (!this.states[this.initial]) {\n                throw new Error(\"Initial state '\" + this.initial + \"' not found on '\" + key + \"'\");\n            }\n            return _b = {}, _b[key] = this.states[this.initial].resolvedStateValue, _b;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    StateNode.prototype.getResolvedPath = function (stateIdentifier) {\n        if (isStateId(stateIdentifier)) {\n            var stateNode = this.machine.idMap[stateIdentifier.slice(STATE_IDENTIFIER.length)];\n            if (!stateNode) {\n                throw new Error(\"Unable to find state node '\" + stateIdentifier + \"'\");\n            }\n            return stateNode.path;\n        }\n        return Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"toStatePath\"])(stateIdentifier, this.delimiter);\n    };\n    Object.defineProperty(StateNode.prototype, \"initialStateValue\", {\n        get: function () {\n            if (this.__cache.initialStateValue) {\n                return this.__cache.initialStateValue;\n            }\n            var initialStateValue = this.type === 'parallel' ? Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"mapFilterValues\"])(this.states, function (state) {\n                return state.initialStateValue || EMPTY_OBJECT;\n            }, function (stateNode) {\n                return !(stateNode.type === 'history');\n            }) : Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isString\"])(this.resolvedStateValue) ? undefined : this.resolvedStateValue[this.key];\n            this.__cache.initialStateValue = initialStateValue;\n            return this.__cache.initialStateValue;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    StateNode.prototype.getInitialState = function (stateValue, context) {\n        if (context === void 0) {\n            context = this.machine.context;\n        }\n        var tree = this.getStateTree(stateValue);\n        var configuration = this.getStateNodes(stateValue);\n        configuration.forEach(function (stateNode) {\n            tree.addReentryNode(stateNode);\n        });\n        return this.resolveTransition({\n            tree: tree,\n            configuration: configuration,\n            transitions: [],\n            source: undefined,\n            actions: [],\n            context: context\n        });\n    };\n    Object.defineProperty(StateNode.prototype, \"initialState\", {\n        /**\n         * The initial State instance, which includes all actions to be executed from\n         * entering the initial state.\n         */\n        get: function () {\n            if (this.__cache.initialState) {\n                return this.__cache.initialState;\n            }\n            var initialStateValue = this.initialStateValue;\n            if (!initialStateValue) {\n                throw new Error(\"Cannot retrieve initial state from simple state '\" + this.id + \"'.\");\n            }\n            this.__cache.initialState = this.getInitialState(initialStateValue);\n            return this.__cache.initialState;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateNode.prototype, \"target\", {\n        /**\n         * The target state value of the history state node, if it exists. This represents the\n         * default state value to transition to if no history value exists yet.\n         */\n        get: function () {\n            var target;\n            if (this.type === 'history') {\n                var historyConfig = this.config;\n                if (historyConfig.target && Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isString\"])(historyConfig.target)) {\n                    target = isStateId(historyConfig.target) ? Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"pathToStateValue\"])(this.machine.getStateNodeById(historyConfig.target).path.slice(this.path.length - 1)) : historyConfig.target;\n                } else {\n                    target = historyConfig.target;\n                }\n            }\n            return target;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    StateNode.prototype.getStates = function (stateValue) {\n        var e_5, _a;\n        if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isString\"])(stateValue)) {\n            return [this.states[stateValue]];\n        }\n        var stateNodes = [];\n        try {\n            for (var _b = __values(Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(stateValue)), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var key = _c.value;\n                stateNodes.push.apply(stateNodes, __spread(this.states[key].getStates(stateValue[key])));\n            }\n        } catch (e_5_1) {\n            e_5 = { error: e_5_1 };\n        } finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            } finally {\n                if (e_5) throw e_5.error;\n            }\n        }\n        return stateNodes;\n    };\n    /**\n     * Returns the leaf nodes from a state path relative to this state node.\n     *\n     * @param relativeStateId The relative state path to retrieve the state nodes\n     * @param history The previous state to retrieve history\n     * @param resolve Whether state nodes should resolve to initial child state nodes\n     */\n    StateNode.prototype.getRelativeStateNodes = function (relativeStateId, historyValue, resolve) {\n        if (resolve === void 0) {\n            resolve = true;\n        }\n        if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isString\"])(relativeStateId) && isStateId(relativeStateId)) {\n            var unresolvedStateNode = this.getStateNodeById(relativeStateId);\n            return resolve ? unresolvedStateNode.type === 'history' ? unresolvedStateNode.resolveHistory(historyValue) : unresolvedStateNode.initialStateNodes : [unresolvedStateNode];\n        }\n        var statePath = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"toStatePath\"])(relativeStateId, this.delimiter);\n        var rootStateNode = this.parent || this;\n        var unresolvedStateNodes = rootStateNode.getFromRelativePath(statePath, historyValue);\n        if (!resolve) {\n            return unresolvedStateNodes;\n        }\n        return Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"flatten\"])(unresolvedStateNodes.map(function (stateNode) {\n            return stateNode.initialStateNodes;\n        }));\n    };\n    Object.defineProperty(StateNode.prototype, \"initialStateNodes\", {\n        get: function () {\n            var _this = this;\n            if (this.type === 'atomic' || this.type === 'final') {\n                return [this];\n            }\n            // Case when state node is compound but no initial state is defined\n            if (this.type === 'compound' && !this.initial) {\n                if (!_environment__WEBPACK_IMPORTED_MODULE_6__[\"IS_PRODUCTION\"]) {\n                    Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"warn\"])(false, \"Compound state node '\" + this.id + \"' has no initial state.\");\n                }\n                return [this];\n            }\n            var initialStateNodePaths = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"toStatePaths\"])(this.initialStateValue);\n            return Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"flatten\"])(initialStateNodePaths.map(function (initialPath) {\n                return _this.getFromRelativePath(initialPath);\n            }));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Retrieves state nodes from a relative path to this state node.\n     *\n     * @param relativePath The relative path from this state node\n     * @param historyValue\n     */\n    StateNode.prototype.getFromRelativePath = function (relativePath, historyValue) {\n        if (!relativePath.length) {\n            return [this];\n        }\n        var _a = __read(relativePath),\n            stateKey = _a[0],\n            childStatePath = _a.slice(1);\n        if (!this.states) {\n            throw new Error(\"Cannot retrieve subPath '\" + stateKey + \"' from node with no states\");\n        }\n        var childStateNode = this.getStateNode(stateKey);\n        if (childStateNode.type === 'history') {\n            return childStateNode.resolveHistory(historyValue);\n        }\n        if (!this.states[stateKey]) {\n            throw new Error(\"Child state '\" + stateKey + \"' does not exist on '\" + this.id + \"'\");\n        }\n        return this.states[stateKey].getFromRelativePath(childStatePath, historyValue);\n    };\n    StateNode.prototype.historyValue = function (relativeStateValue) {\n        if (!Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(this.states).length) {\n            return undefined;\n        }\n        return {\n            current: relativeStateValue || this.initialStateValue,\n            states: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"mapFilterValues\"])(this.states, function (stateNode, key) {\n                if (!relativeStateValue) {\n                    return stateNode.historyValue();\n                }\n                var subStateValue = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isString\"])(relativeStateValue) ? undefined : relativeStateValue[key];\n                return stateNode.historyValue(subStateValue || stateNode.initialStateValue);\n            }, function (stateNode) {\n                return !stateNode.history;\n            })\n        };\n    };\n    /**\n     * Resolves to the historical value(s) of the parent state node,\n     * represented by state nodes.\n     *\n     * @param historyValue\n     */\n    StateNode.prototype.resolveHistory = function (historyValue) {\n        var _this = this;\n        if (this.type !== 'history') {\n            return [this];\n        }\n        var parent = this.parent;\n        if (!historyValue) {\n            return this.target ? Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"flatten\"])(Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"toStatePaths\"])(this.target).map(function (relativeChildPath) {\n                return parent.getFromRelativePath(relativeChildPath);\n            })) : parent.initialStateNodes;\n        }\n        var subHistoryValue = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"nestedPath\"])(parent.path, 'states')(historyValue).current;\n        if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isString\"])(subHistoryValue)) {\n            return [parent.getStateNode(subHistoryValue)];\n        }\n        return Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"flatten\"])(Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"toStatePaths\"])(subHistoryValue).map(function (subStatePath) {\n            return _this.history === 'deep' ? parent.getFromRelativePath(subStatePath) : [parent.states[subStatePath[0]]];\n        }));\n    };\n    Object.defineProperty(StateNode.prototype, \"stateIds\", {\n        /**\n         * All the state node IDs of this state node and its descendant state nodes.\n         */\n        get: function () {\n            var _this = this;\n            var childStateIds = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"flatten\"])(Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(this.states).map(function (stateKey) {\n                return _this.states[stateKey].stateIds;\n            }));\n            return [this.id].concat(childStateIds);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateNode.prototype, \"events\", {\n        /**\n         * All the event types accepted by this state node and its descendants.\n         */\n        get: function () {\n            var e_6, _a, e_7, _b;\n            if (this.__cache.events) {\n                return this.__cache.events;\n            }\n            var states = this.states;\n            var events = new Set(this.ownEvents);\n            if (states) {\n                try {\n                    for (var _c = __values(Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(states)), _d = _c.next(); !_d.done; _d = _c.next()) {\n                        var stateId = _d.value;\n                        var state = states[stateId];\n                        if (state.states) {\n                            try {\n                                for (var _e = __values(state.events), _f = _e.next(); !_f.done; _f = _e.next()) {\n                                    var event_1 = _f.value;\n                                    events.add(\"\" + event_1);\n                                }\n                            } catch (e_7_1) {\n                                e_7 = { error: e_7_1 };\n                            } finally {\n                                try {\n                                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n                                } finally {\n                                    if (e_7) throw e_7.error;\n                                }\n                            }\n                        }\n                    }\n                } catch (e_6_1) {\n                    e_6 = { error: e_6_1 };\n                } finally {\n                    try {\n                        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n                    } finally {\n                        if (e_6) throw e_6.error;\n                    }\n                }\n            }\n            return this.__cache.events = Array.from(events);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateNode.prototype, \"ownEvents\", {\n        /**\n         * All the events that have transitions directly from this state node.\n         *\n         * Excludes any inert events.\n         */\n        get: function () {\n            var _this = this;\n            var events = new Set(Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(this.on).filter(function (key) {\n                var transitions = _this.on[key];\n                return transitions.some(function (transition) {\n                    return !(!transition.target && !transition.actions.length && transition.internal);\n                });\n            }));\n            return Array.from(events);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    StateNode.prototype.formatTransition = function (target, transitionConfig, event) {\n        var _this = this;\n        var internal = transitionConfig ? transitionConfig.internal : undefined;\n        var targets = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"toArray\"])(target);\n        var guards = this.machine.options.guards;\n        // Format targets to their full string path\n        var formattedTargets = targets.map(function (_target) {\n            if (!Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isString\"])(_target)) {\n                return \"#\" + _target.id;\n            }\n            var isInternalTarget = _target[0] === _this.delimiter;\n            internal = internal === undefined ? isInternalTarget : internal;\n            // If internal target is defined on machine,\n            // do not include machine key on target\n            if (isInternalTarget && !_this.parent) {\n                return \"#\" + _this.getStateNodeByPath(_target.slice(1)).id;\n            }\n            var resolvedTarget = isInternalTarget ? _this.key + _target : \"\" + _target;\n            if (_this.parent) {\n                try {\n                    var targetStateNode = _this.parent.getStateNodeByPath(resolvedTarget);\n                    return \"#\" + targetStateNode.id;\n                } catch (err) {\n                    throw new Error(\"Invalid transition for state node '\" + _this.id + \"' on event '\" + event + \"':\\n\" + err.message);\n                }\n            } else {\n                return \"#\" + _this.getStateNodeByPath(resolvedTarget).id;\n            }\n        });\n        if (transitionConfig === undefined) {\n            return {\n                target: target === undefined ? undefined : formattedTargets,\n                source: this,\n                actions: [],\n                internal: target === undefined || internal,\n                event: event\n            };\n        }\n        // Check if there is no target (targetless)\n        // An undefined transition signals that the state node should not transition from that event.\n        var isTargetless = target === undefined || target === TARGETLESS_KEY;\n        return __assign({}, transitionConfig, { actions: Object(_actions__WEBPACK_IMPORTED_MODULE_4__[\"toActionObjects\"])(Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"toArray\"])(transitionConfig.actions)), cond: Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"toGuard\"])(transitionConfig.cond, guards), target: isTargetless ? undefined : formattedTargets, source: this, internal: isTargetless && internal === undefined || internal, event: event });\n    };\n    StateNode.prototype.formatTransitions = function () {\n        var _this = this;\n        var _a, e_8, _b;\n        var onConfig = this.config.on || EMPTY_OBJECT;\n        var doneConfig = this.config.onDone ? (_a = {}, _a[\"\" + Object(_actions__WEBPACK_IMPORTED_MODULE_4__[\"done\"])(this.id)] = this.config.onDone, _a) : undefined;\n        var invokeConfig = this.invoke.reduce(function (acc, invokeDef) {\n            if (invokeDef.onDone) {\n                acc[Object(_actions__WEBPACK_IMPORTED_MODULE_4__[\"doneInvoke\"])(invokeDef.id)] = invokeDef.onDone;\n            }\n            if (invokeDef.onError) {\n                acc[Object(_actions__WEBPACK_IMPORTED_MODULE_4__[\"error\"])(invokeDef.id)] = invokeDef.onError;\n            }\n            return acc;\n        }, {});\n        var delayedTransitions = this.after;\n        var formattedTransitions = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"mapValues\"])(__assign({}, onConfig, doneConfig, invokeConfig), function (value, event) {\n            var e_9, _a;\n            if (value === undefined) {\n                return [{ target: undefined, event: event, actions: [], internal: true }];\n            }\n            if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isArray\"])(value)) {\n                return value.map(function (targetTransitionConfig) {\n                    return _this.formatTransition(targetTransitionConfig.target, targetTransitionConfig, event);\n                });\n            }\n            if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isString\"])(value) || Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isMachine\"])(value)) {\n                return [_this.formatTransition([value], undefined, event)];\n            }\n            if (!_environment__WEBPACK_IMPORTED_MODULE_6__[\"IS_PRODUCTION\"]) {\n                try {\n                    for (var _b = __values(Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(value)), _c = _b.next(); !_c.done; _c = _b.next()) {\n                        var key = _c.value;\n                        if (['target', 'actions', 'internal', 'in', 'cond', 'event'].indexOf(key) === -1) {\n                            throw new Error(\n                            // tslint:disable-next-line:max-line-length\n                            \"State object mapping of transitions is deprecated. Check the config for event '\" + event + \"' on state '\" + _this.id + \"'.\");\n                        }\n                    }\n                } catch (e_9_1) {\n                    e_9 = { error: e_9_1 };\n                } finally {\n                    try {\n                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                    } finally {\n                        if (e_9) throw e_9.error;\n                    }\n                }\n            }\n            return [_this.formatTransition(value.target, value, event)];\n        });\n        try {\n            for (var delayedTransitions_1 = __values(delayedTransitions), delayedTransitions_1_1 = delayedTransitions_1.next(); !delayedTransitions_1_1.done; delayedTransitions_1_1 = delayedTransitions_1.next()) {\n                var delayedTransition = delayedTransitions_1_1.value;\n                formattedTransitions[delayedTransition.event] = formattedTransitions[delayedTransition.event] || [];\n                formattedTransitions[delayedTransition.event].push(delayedTransition);\n            }\n        } catch (e_8_1) {\n            e_8 = { error: e_8_1 };\n        } finally {\n            try {\n                if (delayedTransitions_1_1 && !delayedTransitions_1_1.done && (_b = delayedTransitions_1.return)) _b.call(delayedTransitions_1);\n            } finally {\n                if (e_8) throw e_8.error;\n            }\n        }\n        return formattedTransitions;\n    };\n    return StateNode;\n}();\n\n//# sourceMappingURL=StateNode.js.map\n\n//# sourceURL=webpack:///./node_modules/xstate/es/StateNode.js?");

/***/ }),

/***/ "./node_modules/xstate/es/StateTree.js":
/*!*********************************************!*\
  !*** ./node_modules/xstate/es/StateTree.js ***!
  \*********************************************/
/*! exports provided: StateTree */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StateTree\", function() { return StateTree; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./node_modules/xstate/es/utils.js\");\n/* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./actions */ \"./node_modules/xstate/es/actions.js\");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __read = undefined && undefined.__read || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o),\n        r,\n        ar = [],\n        e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    } catch (error) {\n        e = { error: error };\n    } finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        } finally {\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n};\nvar __spread = undefined && undefined.__spread || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nvar __values = undefined && undefined.__values || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n        i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\n\n\n\nvar defaultStateTreeOptions = {\n    resolved: false\n};\nvar StateTree = /** @class */ /*#__PURE__*/function () {\n    function StateTree(stateNode, stateValue, options, parent) {\n        var _this = this;\n        var _a;\n        if (options === void 0) {\n            options = defaultStateTreeOptions;\n        }\n        this.stateNode = stateNode;\n        this.stateValue = stateValue;\n        this.parent = parent;\n        this.reentryNodes = new Set();\n        this.root = this.parent ? this.parent.root : this;\n        this.nodes = stateValue ? Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isString\"])(stateValue) ? (_a = {}, _a[stateValue] = new StateTree(stateNode.getStateNode(stateValue), undefined, undefined, this), _a) : Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"mapValues\"])(stateValue, function (subValue, key) {\n            return new StateTree(stateNode.getStateNode(key), subValue, undefined, _this);\n        }) : {};\n        var resolvedOptions = __assign({}, defaultStateTreeOptions, options);\n        this.isResolved = resolvedOptions.resolved;\n    }\n    Object.defineProperty(StateTree.prototype, \"done\", {\n        get: function () {\n            var _this = this;\n            switch (this.stateNode.type) {\n                case 'final':\n                    return true;\n                case 'compound':\n                    var childTree = this.nodes[Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(this.nodes)[0]];\n                    return childTree.stateNode.type === 'final';\n                case 'parallel':\n                    return Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(this.nodes).every(function (key) {\n                        return _this.nodes[key].done;\n                    });\n                default:\n                    return false;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    StateTree.prototype.getDoneData = function (context, event) {\n        if (!this.done) {\n            return undefined;\n        }\n        if (this.stateNode.type === 'compound') {\n            var childTree = this.nodes[Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(this.nodes)[0]];\n            if (!childTree.stateNode.data) {\n                return undefined;\n            }\n            return Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"mapContext\"])(childTree.stateNode.data, context, event);\n        }\n        return undefined;\n    };\n    Object.defineProperty(StateTree.prototype, \"atomicNodes\", {\n        get: function () {\n            var _this = this;\n            if (this.stateNode.type === 'atomic' || this.stateNode.type === 'final') {\n                return [this.stateNode];\n            }\n            return Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"flatten\"])(Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(this.value).map(function (key) {\n                return _this.value[key].atomicNodes;\n            }));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    StateTree.prototype.getDoneEvents = function (entryStateNodes) {\n        var _this = this;\n        // If no state nodes are being entered, no done events will be fired\n        if (!entryStateNodes || !entryStateNodes.size) {\n            return [];\n        }\n        if (entryStateNodes.has(this.stateNode) && this.stateNode.type === 'final') {\n            return [Object(_actions__WEBPACK_IMPORTED_MODULE_1__[\"done\"])(this.stateNode.id, this.stateNode.data)];\n        }\n        var childDoneEvents = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"flatten\"])(Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(this.nodes).map(function (key) {\n            return _this.nodes[key].getDoneEvents(entryStateNodes);\n        }));\n        if (this.stateNode.type === 'parallel') {\n            var allChildrenDone = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(this.nodes).every(function (key) {\n                return _this.nodes[key].done;\n            });\n            if (childDoneEvents && allChildrenDone) {\n                return childDoneEvents.concat(Object(_actions__WEBPACK_IMPORTED_MODULE_1__[\"done\"])(this.stateNode.id));\n            } else {\n                return childDoneEvents;\n            }\n        }\n        if (!this.done || !childDoneEvents.length) {\n            return childDoneEvents;\n        }\n        // TODO: handle merging strategy\n        // For compound state nodes with final child state, there should be only\n        // one done.state event (potentially with data).\n        var doneData = childDoneEvents.length === 1 ? childDoneEvents[0].data : undefined;\n        return childDoneEvents.concat(Object(_actions__WEBPACK_IMPORTED_MODULE_1__[\"done\"])(this.stateNode.id, doneData));\n    };\n    Object.defineProperty(StateTree.prototype, \"resolved\", {\n        get: function () {\n            var newStateTree = new StateTree(this.stateNode, this.stateNode.resolve(this.value), {\n                resolved: true\n            });\n            newStateTree.reentryNodes = this.reentryNodes;\n            return newStateTree;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateTree.prototype, \"paths\", {\n        get: function () {\n            return Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"toStatePaths\"])(this.value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateTree.prototype, \"absolute\", {\n        get: function () {\n            var _stateValue = this.stateValue;\n            var absoluteStateValue = {};\n            var marker = absoluteStateValue;\n            for (var i = 0; i < this.stateNode.path.length; i++) {\n                var key = this.stateNode.path[i];\n                if (i === this.stateNode.path.length - 1) {\n                    marker[key] = _stateValue;\n                } else {\n                    marker[key] = {};\n                    marker = marker[key];\n                }\n            }\n            var newStateTree = new StateTree(this.stateNode.machine, absoluteStateValue);\n            newStateTree.reentryNodes = this.reentryNodes;\n            return newStateTree;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateTree.prototype, \"nextEvents\", {\n        get: function () {\n            var _this = this;\n            var ownEvents = this.stateNode.ownEvents;\n            var childEvents = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"flatten\"])(Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(this.nodes).map(function (key) {\n                var subTree = _this.nodes[key];\n                return subTree.nextEvents;\n            }));\n            return __spread(new Set(childEvents.concat(ownEvents)));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    StateTree.prototype.clone = function () {\n        var newStateTree = new StateTree(this.stateNode, this.value, undefined, this.parent);\n        return newStateTree;\n    };\n    StateTree.prototype.combine = function (tree) {\n        var _a, e_1, _b;\n        if (tree.stateNode !== this.stateNode) {\n            throw new Error('Cannot combine distinct trees');\n        }\n        var newTree = this.clone();\n        tree.root.reentryNodes.forEach(function (reentryNode) {\n            newTree.root.addReentryNode(reentryNode);\n        });\n        if (this.stateNode.type === 'compound') {\n            // Only combine if no child state is defined\n            var newValue = void 0;\n            if (!Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(this.nodes).length || !Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(tree.nodes).length) {\n                newValue = Object.assign({}, this.nodes, tree.nodes);\n                newTree.nodes = newValue;\n                return newTree;\n            } else {\n                var childKey = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(this.nodes)[0];\n                newValue = (_a = {}, _a[childKey] = this.nodes[childKey].combine(tree.nodes[childKey]), _a);\n                newTree.nodes = newValue;\n                return newTree;\n            }\n        }\n        if (this.stateNode.type === 'parallel') {\n            var valueKeys = new Set(__spread(Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(this.nodes), Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(tree.nodes)));\n            var newValue = {};\n            try {\n                for (var valueKeys_1 = __values(valueKeys), valueKeys_1_1 = valueKeys_1.next(); !valueKeys_1_1.done; valueKeys_1_1 = valueKeys_1.next()) {\n                    var key = valueKeys_1_1.value;\n                    if (!this.nodes[key] || !tree.nodes[key]) {\n                        newValue[key] = this.nodes[key] || tree.nodes[key];\n                    } else {\n                        newValue[key] = this.nodes[key].combine(tree.nodes[key]);\n                    }\n                }\n            } catch (e_1_1) {\n                e_1 = { error: e_1_1 };\n            } finally {\n                try {\n                    if (valueKeys_1_1 && !valueKeys_1_1.done && (_b = valueKeys_1.return)) _b.call(valueKeys_1);\n                } finally {\n                    if (e_1) throw e_1.error;\n                }\n            }\n            newTree.nodes = newValue;\n            return newTree;\n        }\n        // nothing to do\n        return this;\n    };\n    Object.defineProperty(StateTree.prototype, \"value\", {\n        get: function () {\n            if (this.stateNode.type === 'atomic' || this.stateNode.type === 'final') {\n                return {};\n            }\n            if (this.stateNode.type === 'parallel') {\n                return Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"mapValues\"])(this.nodes, function (st) {\n                    return st.value;\n                });\n            }\n            if (this.stateNode.type === 'compound') {\n                if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(this.nodes).length === 0) {\n                    return {};\n                }\n                var childStateNode = this.nodes[Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(this.nodes)[0]].stateNode;\n                if (childStateNode.type === 'atomic' || childStateNode.type === 'final') {\n                    return childStateNode.key;\n                }\n                return Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"mapValues\"])(this.nodes, function (st) {\n                    return st.value;\n                });\n            }\n            return {};\n        },\n        enumerable: true,\n        configurable: true\n    });\n    StateTree.prototype.matches = function (parentValue) {\n        return Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"matchesState\"])(parentValue, this.value);\n    };\n    StateTree.prototype.getEntryExitStates = function (prevTree) {\n        var _this = this;\n        var e_2, _a;\n        var externalNodes = this.root.reentryNodes;\n        if (!prevTree) {\n            // Initial state\n            return {\n                exit: [],\n                entry: __spread(externalNodes)\n            };\n        }\n        if (prevTree.stateNode !== this.stateNode) {\n            throw new Error('Cannot compare distinct trees');\n        }\n        switch (this.stateNode.type) {\n            case 'compound':\n                var compoundResult = {\n                    exit: [],\n                    entry: []\n                };\n                var currentChildKey = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(this.nodes)[0];\n                var prevChildKey = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(prevTree.nodes)[0];\n                if (currentChildKey !== prevChildKey) {\n                    compoundResult.exit = prevTree.nodes[prevChildKey].getExitStates();\n                    compoundResult.entry = this.nodes[currentChildKey].getEntryStates();\n                } else {\n                    compoundResult = this.nodes[currentChildKey].getEntryExitStates(prevTree.nodes[prevChildKey]);\n                }\n                if (externalNodes && externalNodes.has(this.stateNode)) {\n                    compoundResult.exit.push(this.stateNode);\n                    compoundResult.entry.unshift(this.stateNode);\n                }\n                return compoundResult;\n            case 'parallel':\n                var all = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(this.nodes).map(function (key) {\n                    return _this.nodes[key].getEntryExitStates(prevTree.nodes[key]);\n                });\n                var parallelResult = {\n                    exit: [],\n                    entry: []\n                };\n                try {\n                    for (var all_1 = __values(all), all_1_1 = all_1.next(); !all_1_1.done; all_1_1 = all_1.next()) {\n                        var ees = all_1_1.value;\n                        parallelResult.exit = __spread(parallelResult.exit, ees.exit);\n                        parallelResult.entry = __spread(parallelResult.entry, ees.entry);\n                    }\n                } catch (e_2_1) {\n                    e_2 = { error: e_2_1 };\n                } finally {\n                    try {\n                        if (all_1_1 && !all_1_1.done && (_a = all_1.return)) _a.call(all_1);\n                    } finally {\n                        if (e_2) throw e_2.error;\n                    }\n                }\n                if (externalNodes && externalNodes.has(this.stateNode)) {\n                    parallelResult.exit.push(this.stateNode);\n                    parallelResult.entry.unshift(this.stateNode);\n                }\n                return parallelResult;\n            case 'atomic':\n            default:\n                if (externalNodes && externalNodes.has(this.stateNode)) {\n                    return {\n                        exit: [this.stateNode],\n                        entry: [this.stateNode]\n                    };\n                }\n                return {\n                    exit: [],\n                    entry: []\n                };\n        }\n    };\n    StateTree.prototype.getEntryStates = function () {\n        var _this = this;\n        if (!this.nodes) {\n            return [this.stateNode];\n        }\n        return [this.stateNode].concat(Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"flatten\"])(Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(this.nodes).map(function (key) {\n            return _this.nodes[key].getEntryStates();\n        })));\n    };\n    StateTree.prototype.getExitStates = function () {\n        var _this = this;\n        if (!this.nodes) {\n            return [this.stateNode];\n        }\n        return Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"flatten\"])(Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(this.nodes).map(function (key) {\n            return _this.nodes[key].getExitStates();\n        })).concat(this.stateNode);\n    };\n    StateTree.prototype.addReentryNode = function (reentryNode) {\n        this.root.reentryNodes.add(reentryNode);\n    };\n    return StateTree;\n}();\n\n//# sourceMappingURL=StateTree.js.map\n\n//# sourceURL=webpack:///./node_modules/xstate/es/StateTree.js?");

/***/ }),

/***/ "./node_modules/xstate/es/actionTypes.js":
/*!***********************************************!*\
  !*** ./node_modules/xstate/es/actionTypes.js ***!
  \***********************************************/
/*! exports provided: start, stop, raise, send, cancel, nullEvent, assign, after, doneState, log, init, invoke, errorExecution, errorPlatform, update */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"start\", function() { return start; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stop\", function() { return stop; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"raise\", function() { return raise; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"send\", function() { return send; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cancel\", function() { return cancel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"nullEvent\", function() { return nullEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"assign\", function() { return assign; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"after\", function() { return after; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"doneState\", function() { return doneState; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"log\", function() { return log; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"init\", function() { return init; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"invoke\", function() { return invoke; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"errorExecution\", function() { return errorExecution; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"errorPlatform\", function() { return errorPlatform; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"update\", function() { return update; });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./node_modules/xstate/es/types.js\");\n\n// xstate-specific action types\nvar start = _types__WEBPACK_IMPORTED_MODULE_0__[\"ActionTypes\"].Start;\nvar stop = _types__WEBPACK_IMPORTED_MODULE_0__[\"ActionTypes\"].Stop;\nvar raise = _types__WEBPACK_IMPORTED_MODULE_0__[\"ActionTypes\"].Raise;\nvar send = _types__WEBPACK_IMPORTED_MODULE_0__[\"ActionTypes\"].Send;\nvar cancel = _types__WEBPACK_IMPORTED_MODULE_0__[\"ActionTypes\"].Cancel;\nvar nullEvent = _types__WEBPACK_IMPORTED_MODULE_0__[\"ActionTypes\"].NullEvent;\nvar assign = _types__WEBPACK_IMPORTED_MODULE_0__[\"ActionTypes\"].Assign;\nvar after = _types__WEBPACK_IMPORTED_MODULE_0__[\"ActionTypes\"].After;\nvar doneState = _types__WEBPACK_IMPORTED_MODULE_0__[\"ActionTypes\"].DoneState;\nvar log = _types__WEBPACK_IMPORTED_MODULE_0__[\"ActionTypes\"].Log;\nvar init = _types__WEBPACK_IMPORTED_MODULE_0__[\"ActionTypes\"].Init;\nvar invoke = _types__WEBPACK_IMPORTED_MODULE_0__[\"ActionTypes\"].Invoke;\nvar errorExecution = _types__WEBPACK_IMPORTED_MODULE_0__[\"ActionTypes\"].ErrorExecution;\nvar errorPlatform = _types__WEBPACK_IMPORTED_MODULE_0__[\"ActionTypes\"].ErrorPlatform;\nvar update = _types__WEBPACK_IMPORTED_MODULE_0__[\"ActionTypes\"].Update;\n//# sourceMappingURL=actionTypes.js.map\n\n//# sourceURL=webpack:///./node_modules/xstate/es/actionTypes.js?");

/***/ }),

/***/ "./node_modules/xstate/es/actions.js":
/*!*******************************************!*\
  !*** ./node_modules/xstate/es/actions.js ***!
  \*******************************************/
/*! exports provided: actionTypes, initEvent, toEventObject, getActionFunction, toActionObject, toActionObjects, toActivityDefinition, raise, send, resolveSend, sendParent, log, cancel, start, stop, assign, isActionObject, after, done, doneInvoke, error, pure */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"initEvent\", function() { return initEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toEventObject\", function() { return toEventObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getActionFunction\", function() { return getActionFunction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toActionObject\", function() { return toActionObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toActionObjects\", function() { return toActionObjects; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toActivityDefinition\", function() { return toActivityDefinition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"raise\", function() { return raise; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"send\", function() { return send; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"resolveSend\", function() { return resolveSend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sendParent\", function() { return sendParent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"log\", function() { return log; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cancel\", function() { return cancel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"start\", function() { return start; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stop\", function() { return stop; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"assign\", function() { return assign; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isActionObject\", function() { return isActionObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"after\", function() { return after; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"done\", function() { return done; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"doneInvoke\", function() { return doneInvoke; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"error\", function() { return error; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pure\", function() { return pure; });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./node_modules/xstate/es/types.js\");\n/* harmony import */ var _actionTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./actionTypes */ \"./node_modules/xstate/es/actionTypes.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"actionTypes\", function() { return _actionTypes__WEBPACK_IMPORTED_MODULE_1__; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./node_modules/xstate/es/utils.js\");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __rest = undefined && undefined.__rest || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n    return t;\n};\n\n\n\n\n\nvar initEvent = { type: _actionTypes__WEBPACK_IMPORTED_MODULE_1__[\"init\"] };\nfunction toEventObject(event, payload\n// id?: TEvent['type']\n) {\n    if (Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"isString\"])(event) || typeof event === 'number') {\n        var eventObject = { type: event };\n        if (payload) {\n            Object.assign(eventObject, payload);\n        }\n        return eventObject;\n    }\n    return event;\n}\nfunction getActionFunction(actionType, actionFunctionMap) {\n    return actionFunctionMap ? actionFunctionMap[actionType] || undefined : undefined;\n}\nfunction toActionObject(action, actionFunctionMap) {\n    var actionObject;\n    if (Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"isString\"])(action) || typeof action === 'number') {\n        var exec = getActionFunction(action, actionFunctionMap);\n        if (Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"isFunction\"])(exec)) {\n            actionObject = {\n                type: action,\n                exec: exec\n            };\n        } else if (exec) {\n            actionObject = exec;\n        } else {\n            actionObject = { type: action, exec: undefined };\n        }\n    } else if (Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"isFunction\"])(action)) {\n        actionObject = {\n            // Convert action to string if unnamed\n            type: action.name || action.toString(),\n            exec: action\n        };\n    } else {\n        var exec = getActionFunction(action.type, actionFunctionMap);\n        if (Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"isFunction\"])(exec)) {\n            actionObject = __assign({}, action, { exec: exec });\n        } else if (exec) {\n            var type = action.type,\n                other = __rest(action, [\"type\"]);\n            actionObject = __assign({ type: type }, exec, other);\n        } else {\n            actionObject = action;\n        }\n    }\n    Object.defineProperty(actionObject, 'toString', {\n        value: function () {\n            return actionObject.type;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return actionObject;\n}\nvar toActionObjects = function (action, actionFunctionMap) {\n    if (!action) {\n        return [];\n    }\n    var actions = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"isArray\"])(action) ? action : [action];\n    return actions.map(function (subAction) {\n        return toActionObject(subAction, actionFunctionMap);\n    });\n};\nfunction toActivityDefinition(action) {\n    var actionObject = toActionObject(action);\n    return __assign({ id: Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"isString\"])(action) ? action : actionObject.id }, actionObject, { type: actionObject.type });\n}\n/**\n * Raises an event. This places the event in the internal event queue, so that\n * the event is immediately consumed by the machine in the current step.\n *\n * @param eventType The event to raise.\n */\nfunction raise(event) {\n    return {\n        type: _actionTypes__WEBPACK_IMPORTED_MODULE_1__[\"raise\"],\n        event: event\n    };\n}\n/**\n * Sends an event. This returns an action that will be read by an interpreter to\n * send the event in the next step, after the current step is finished executing.\n *\n * @param event The event to send.\n * @param options Options to pass into the send event:\n *  - `id` - The unique send event identifier (used with `cancel()`).\n *  - `delay` - The number of milliseconds to delay the sending of the event.\n *  - `target` - The target of this event (by default, the machine the event was sent from).\n */\nfunction send(event, options) {\n    return {\n        to: options ? options.to : undefined,\n        type: _actionTypes__WEBPACK_IMPORTED_MODULE_1__[\"send\"],\n        event: Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"isFunction\"])(event) ? event : toEventObject(event),\n        delay: options ? options.delay : undefined,\n        id: options && options.id !== undefined ? options.id : Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"isFunction\"])(event) ? event.name : Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"getEventType\"])(event)\n    };\n}\nfunction resolveSend(action, ctx, event) {\n    // TODO: helper function for resolving Expr\n    var resolvedEvent = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"isFunction\"])(action.event) ? toEventObject(action.event(ctx, event)) : toEventObject(action.event);\n    var resolvedDelay = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"isFunction\"])(action.delay) ? action.delay(ctx, event) : action.delay;\n    var resolvedTarget = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"isFunction\"])(action.to) ? action.to(ctx, event) : action.to;\n    return __assign({}, action, { to: resolvedTarget, event: resolvedEvent, delay: resolvedDelay });\n}\n/**\n * Sends an event to this machine's parent machine.\n *\n * @param event The event to send to the parent machine.\n * @param options Options to pass into the send event.\n */\nfunction sendParent(event, options) {\n    return send(event, __assign({}, options, { to: _types__WEBPACK_IMPORTED_MODULE_0__[\"SpecialTargets\"].Parent }));\n}\n/**\n *\n * @param expr The expression function to evaluate which will be logged.\n *  Takes in 2 arguments:\n *  - `ctx` - the current state context\n *  - `event` - the event that caused this action to be executed.\n * @param label The label to give to the logged expression.\n */\nfunction log(expr, label) {\n    if (expr === void 0) {\n        expr = function (context, event) {\n            return {\n                context: context,\n                event: event\n            };\n        };\n    }\n    return {\n        type: _actionTypes__WEBPACK_IMPORTED_MODULE_1__[\"log\"],\n        label: label,\n        expr: expr\n    };\n}\n/**\n * Cancels an in-flight `send(...)` action. A canceled sent action will not\n * be executed, nor will its event be sent, unless it has already been sent\n * (e.g., if `cancel(...)` is called after the `send(...)` action's `delay`).\n *\n * @param sendId The `id` of the `send(...)` action to cancel.\n */\nvar cancel = function (sendId) {\n    return {\n        type: _actionTypes__WEBPACK_IMPORTED_MODULE_1__[\"cancel\"],\n        sendId: sendId\n    };\n};\n/**\n * Starts an activity.\n *\n * @param activity The activity to start.\n */\nfunction start(activity) {\n    var activityDef = toActivityDefinition(activity);\n    return {\n        type: _types__WEBPACK_IMPORTED_MODULE_0__[\"ActionTypes\"].Start,\n        activity: activityDef,\n        exec: undefined\n    };\n}\n/**\n * Stops an activity.\n *\n * @param activity The activity to stop.\n */\nfunction stop(activity) {\n    var activityDef = toActivityDefinition(activity);\n    return {\n        type: _types__WEBPACK_IMPORTED_MODULE_0__[\"ActionTypes\"].Stop,\n        activity: activityDef,\n        exec: undefined\n    };\n}\n/**\n * Updates the current context of the machine.\n *\n * @param assignment An object that represents the partial context to update.\n */\nvar assign = function (assignment) {\n    return {\n        type: _actionTypes__WEBPACK_IMPORTED_MODULE_1__[\"assign\"],\n        assignment: assignment\n    };\n};\nfunction isActionObject(action) {\n    return typeof action === 'object' && 'type' in action;\n}\n/**\n * Returns an event type that represents an implicit event that\n * is sent after the specified `delay`.\n *\n * @param delayRef The delay in milliseconds\n * @param id The state node ID where this event is handled\n */\nfunction after(delayRef, id) {\n    var idSuffix = id ? \"#\" + id : '';\n    return _types__WEBPACK_IMPORTED_MODULE_0__[\"ActionTypes\"].After + \"(\" + delayRef + \")\" + idSuffix;\n}\n/**\n * Returns an event that represents that a final state node\n * has been reached in the parent state node.\n *\n * @param id The final state node's parent state node `id`\n * @param data The data to pass into the event\n */\nfunction done(id, data) {\n    var type = _types__WEBPACK_IMPORTED_MODULE_0__[\"ActionTypes\"].DoneState + \".\" + id;\n    var eventObject = {\n        type: type,\n        data: data\n    };\n    eventObject.toString = function () {\n        return type;\n    };\n    return eventObject;\n}\n/**\n * Returns an event that represents that an invoked service has terminated.\n *\n * An invoked service is terminated when it has reached a top-level final state node,\n * but not when it is canceled.\n *\n * @param id The final state node ID\n * @param data The data to pass into the event\n */\nfunction doneInvoke(id, data) {\n    var type = _types__WEBPACK_IMPORTED_MODULE_0__[\"ActionTypes\"].DoneInvoke + \".\" + id;\n    var eventObject = {\n        type: type,\n        data: data\n    };\n    eventObject.toString = function () {\n        return type;\n    };\n    return eventObject;\n}\nfunction error(id, data) {\n    var type = _types__WEBPACK_IMPORTED_MODULE_0__[\"ActionTypes\"].ErrorPlatform + \".\" + id;\n    var eventObject = { type: type, data: data };\n    eventObject.toString = function () {\n        return type;\n    };\n    return eventObject;\n}\nfunction pure(getActions) {\n    return {\n        type: _types__WEBPACK_IMPORTED_MODULE_0__[\"ActionTypes\"].Pure,\n        get: getActions\n    };\n}\n//# sourceMappingURL=actions.js.map\n\n//# sourceURL=webpack:///./node_modules/xstate/es/actions.js?");

/***/ }),

/***/ "./node_modules/xstate/es/constants.js":
/*!*********************************************!*\
  !*** ./node_modules/xstate/es/constants.js ***!
  \*********************************************/
/*! exports provided: STATE_DELIMITER, EMPTY_ACTIVITY_MAP, DEFAULT_GUARD_TYPE */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"STATE_DELIMITER\", function() { return STATE_DELIMITER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EMPTY_ACTIVITY_MAP\", function() { return EMPTY_ACTIVITY_MAP; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_GUARD_TYPE\", function() { return DEFAULT_GUARD_TYPE; });\nvar STATE_DELIMITER = '.';\nvar EMPTY_ACTIVITY_MAP = {};\nvar DEFAULT_GUARD_TYPE = 'xstate.guard';\n//# sourceMappingURL=constants.js.map\n\n//# sourceURL=webpack:///./node_modules/xstate/es/constants.js?");

/***/ }),

/***/ "./node_modules/xstate/es/environment.js":
/*!***********************************************!*\
  !*** ./node_modules/xstate/es/environment.js ***!
  \***********************************************/
/*! exports provided: IS_PRODUCTION */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IS_PRODUCTION\", function() { return IS_PRODUCTION; });\nvar IS_PRODUCTION = \"development\" === 'production';\n//# sourceMappingURL=environment.js.map\n\n//# sourceURL=webpack:///./node_modules/xstate/es/environment.js?");

/***/ }),

/***/ "./node_modules/xstate/es/index.js":
/*!*****************************************!*\
  !*** ./node_modules/xstate/es/index.js ***!
  \*****************************************/
/*! exports provided: Machine, StateNode, State, matchesState, mapState, actions, assign, send, sendParent, interpret, Interpreter, matchState, spawn, ActionTypes, SpecialTargets */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"actions\", function() { return actions; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./node_modules/xstate/es/utils.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"matchesState\", function() { return _utils__WEBPACK_IMPORTED_MODULE_0__[\"matchesState\"]; });\n\n/* harmony import */ var _mapState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mapState */ \"./node_modules/xstate/es/mapState.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"mapState\", function() { return _mapState__WEBPACK_IMPORTED_MODULE_1__[\"mapState\"]; });\n\n/* harmony import */ var _StateNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StateNode */ \"./node_modules/xstate/es/StateNode.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"StateNode\", function() { return _StateNode__WEBPACK_IMPORTED_MODULE_2__[\"StateNode\"]; });\n\n/* harmony import */ var _State__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./State */ \"./node_modules/xstate/es/State.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"State\", function() { return _State__WEBPACK_IMPORTED_MODULE_3__[\"State\"]; });\n\n/* harmony import */ var _Machine__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Machine */ \"./node_modules/xstate/es/Machine.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Machine\", function() { return _Machine__WEBPACK_IMPORTED_MODULE_4__[\"Machine\"]; });\n\n/* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./actions */ \"./node_modules/xstate/es/actions.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"assign\", function() { return _actions__WEBPACK_IMPORTED_MODULE_5__[\"assign\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"send\", function() { return _actions__WEBPACK_IMPORTED_MODULE_5__[\"send\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"sendParent\", function() { return _actions__WEBPACK_IMPORTED_MODULE_5__[\"sendParent\"]; });\n\n/* harmony import */ var _interpreter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./interpreter */ \"./node_modules/xstate/es/interpreter.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"interpret\", function() { return _interpreter__WEBPACK_IMPORTED_MODULE_6__[\"interpret\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Interpreter\", function() { return _interpreter__WEBPACK_IMPORTED_MODULE_6__[\"Interpreter\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"spawn\", function() { return _interpreter__WEBPACK_IMPORTED_MODULE_6__[\"spawn\"]; });\n\n/* harmony import */ var _match__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./match */ \"./node_modules/xstate/es/match.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"matchState\", function() { return _match__WEBPACK_IMPORTED_MODULE_7__[\"matchState\"]; });\n\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./types */ \"./node_modules/xstate/es/types.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ActionTypes\", function() { return _types__WEBPACK_IMPORTED_MODULE_8__[\"ActionTypes\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"SpecialTargets\", function() { return _types__WEBPACK_IMPORTED_MODULE_8__[\"SpecialTargets\"]; });\n\n\n\n\n\n\n\n\n\nvar actions = {\n    raise: _actions__WEBPACK_IMPORTED_MODULE_5__[\"raise\"],\n    send: _actions__WEBPACK_IMPORTED_MODULE_5__[\"send\"],\n    sendParent: _actions__WEBPACK_IMPORTED_MODULE_5__[\"sendParent\"],\n    log: _actions__WEBPACK_IMPORTED_MODULE_5__[\"log\"],\n    cancel: _actions__WEBPACK_IMPORTED_MODULE_5__[\"cancel\"],\n    start: _actions__WEBPACK_IMPORTED_MODULE_5__[\"start\"],\n    stop: _actions__WEBPACK_IMPORTED_MODULE_5__[\"stop\"],\n    assign: _actions__WEBPACK_IMPORTED_MODULE_5__[\"assign\"],\n    after: _actions__WEBPACK_IMPORTED_MODULE_5__[\"after\"],\n    done: _actions__WEBPACK_IMPORTED_MODULE_5__[\"done\"]\n};\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/xstate/es/index.js?");

/***/ }),

/***/ "./node_modules/xstate/es/interpreter.js":
/*!***********************************************!*\
  !*** ./node_modules/xstate/es/interpreter.js ***!
  \***********************************************/
/*! exports provided: Interpreter, spawn, interpret */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Interpreter\", function() { return Interpreter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"spawn\", function() { return spawn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"interpret\", function() { return interpret; });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./node_modules/xstate/es/types.js\");\n/* harmony import */ var _State__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./State */ \"./node_modules/xstate/es/State.js\");\n/* harmony import */ var _actionTypes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./actionTypes */ \"./node_modules/xstate/es/actionTypes.js\");\n/* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./actions */ \"./node_modules/xstate/es/actions.js\");\n/* harmony import */ var _environment__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./environment */ \"./node_modules/xstate/es/environment.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils */ \"./node_modules/xstate/es/utils.js\");\n/* harmony import */ var _scheduler__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./scheduler */ \"./node_modules/xstate/es/scheduler.js\");\n/* harmony import */ var _Actor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Actor */ \"./node_modules/xstate/es/Actor.js\");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __values = undefined && undefined.__values || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n        i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nvar __read = undefined && undefined.__read || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o),\n        r,\n        ar = [],\n        e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    } catch (error) {\n        e = { error: error };\n    } finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        } finally {\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n};\nvar __spread = undefined && undefined.__spread || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\n\n\n\n\n\n\n\n\nvar DEFAULT_SPAWN_OPTIONS = { sync: false, autoForward: false };\n/**\n * Maintains a stack of the current service in scope.\n * This is used to provide the correct service to spawn().\n *\n * @private\n */\nvar withServiceScope = /*#__PURE__*/function () {\n    var serviceStack = [];\n    return function (service, fn) {\n        service && serviceStack.push(service);\n        var result = fn(service || serviceStack[serviceStack.length - 1]);\n        service && serviceStack.pop();\n        return result;\n    };\n}();\nvar Interpreter = /** @class */ /*#__PURE__*/function () {\n    /**\n     * Creates a new Interpreter instance (i.e., service) for the given machine with the provided options, if any.\n     *\n     * @param machine The machine to be interpreted\n     * @param options Interpreter options\n     */\n    function Interpreter(machine, options) {\n        var _this = this;\n        if (options === void 0) {\n            options = Interpreter.defaultOptions;\n        }\n        this.machine = machine;\n        this.scheduler = new _scheduler__WEBPACK_IMPORTED_MODULE_6__[\"Scheduler\"]();\n        this.delayedEventsMap = {};\n        this.listeners = new Set();\n        this.contextListeners = new Set();\n        this.stopListeners = new Set();\n        this.doneListeners = new Set();\n        this.eventListeners = new Set();\n        this.sendListeners = new Set();\n        /**\n         * Whether the service is started.\n         */\n        this.initialized = false;\n        this.children = new Map();\n        this.forwardTo = new Set();\n        /**\n         * Alias for Interpreter.prototype.start\n         */\n        this.init = this.start;\n        /**\n         * Sends an event to the running interpreter to trigger a transition.\n         *\n         * An array of events (batched) can be sent as well, which will send all\n         * batched events to the running interpreter. The listeners will be\n         * notified only **once** when all events are processed.\n         *\n         * @param event The event(s) to send\n         */\n        this.send = function (event, payload) {\n            if (Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"isArray\"])(event)) {\n                _this.batch(event);\n                return _this.state;\n            }\n            var eventObject = Object(_actions__WEBPACK_IMPORTED_MODULE_3__[\"toEventObject\"])(event, payload);\n            if (!_this.initialized && _this.options.deferEvents) {\n                // tslint:disable-next-line:no-console\n                if (!_environment__WEBPACK_IMPORTED_MODULE_4__[\"IS_PRODUCTION\"]) {\n                    Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"warn\"])(false, \"Event \\\"\" + eventObject.type + \"\\\" was sent to uninitialized service \\\"\" + _this.machine.id + \"\\\" and is deferred. Make sure .start() is called for this service.\\nEvent: \" + JSON.stringify(event));\n                }\n            } else if (!_this.initialized) {\n                throw new Error(\"Event \\\"\" + eventObject.type + \"\\\" was sent to uninitialized service \\\"\" + _this.machine.id + \"\\\". Make sure .start() is called for this service, or set { deferEvents: true } in the service options.\\nEvent: \" + JSON.stringify(eventObject));\n            }\n            _this.scheduler.schedule(function () {\n                var nextState = _this.nextState(eventObject);\n                _this.update(nextState, eventObject);\n                // Forward copy of event to child interpreters\n                _this.forward(eventObject);\n            });\n            return _this.state; // TODO: deprecate (should return void)\n            // tslint:disable-next-line:semicolon\n        };\n        this.sendTo = function (event, to) {\n            var isParent = to === _types__WEBPACK_IMPORTED_MODULE_0__[\"SpecialTargets\"].Parent;\n            var target = isParent ? _this.parent : Object(_Actor__WEBPACK_IMPORTED_MODULE_7__[\"isActor\"])(to) ? to : _this.children.get(to);\n            if (!target) {\n                if (!isParent) {\n                    throw new Error(\"Unable to send event to child '\" + to + \"' from service '\" + _this.id + \"'.\");\n                }\n                // tslint:disable-next-line:no-console\n                if (!_environment__WEBPACK_IMPORTED_MODULE_4__[\"IS_PRODUCTION\"]) {\n                    Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"warn\"])(false, \"Service '\" + _this.id + \"' has no parent: unable to send event \" + event.type);\n                }\n                return;\n            }\n            target.send(event);\n        };\n        var resolvedOptions = __assign({}, Interpreter.defaultOptions, options);\n        var clock = resolvedOptions.clock,\n            logger = resolvedOptions.logger,\n            parent = resolvedOptions.parent,\n            id = resolvedOptions.id;\n        var resolvedId = id !== undefined ? id : machine.id;\n        this.id = resolvedId;\n        this.logger = logger;\n        this.clock = clock;\n        this.parent = parent;\n        this.options = resolvedOptions;\n        this.scheduler = new _scheduler__WEBPACK_IMPORTED_MODULE_6__[\"Scheduler\"]({\n            deferEvents: this.options.deferEvents\n        });\n        this.initialState = this.state = withServiceScope(this, function () {\n            return _this.machine.initialState;\n        });\n    }\n    /**\n     * Executes the actions of the given state, with that state's `context` and `event`.\n     *\n     * @param state The state whose actions will be executed\n     * @param actionsConfig The action implementations to use\n     */\n    Interpreter.prototype.execute = function (state, actionsConfig) {\n        var e_1, _a;\n        try {\n            for (var _b = __values(state.actions), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var action = _c.value;\n                this.exec(action, state.context, state.event, actionsConfig);\n            }\n        } catch (e_1_1) {\n            e_1 = { error: e_1_1 };\n        } finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            } finally {\n                if (e_1) throw e_1.error;\n            }\n        }\n    };\n    Interpreter.prototype.update = function (state, event) {\n        var e_2, _a, e_3, _b, e_4, _c, e_5, _d;\n        // Update state\n        this.state = state;\n        // Execute actions\n        if (this.options.execute) {\n            this.execute(this.state);\n        }\n        // Dev tools\n        if (this.devTools) {\n            this.devTools.send(event, state);\n        }\n        // Execute listeners\n        if (state.event) {\n            try {\n                for (var _e = __values(this.eventListeners), _f = _e.next(); !_f.done; _f = _e.next()) {\n                    var listener = _f.value;\n                    listener(state.event);\n                }\n            } catch (e_2_1) {\n                e_2 = { error: e_2_1 };\n            } finally {\n                try {\n                    if (_f && !_f.done && (_a = _e.return)) _a.call(_e);\n                } finally {\n                    if (e_2) throw e_2.error;\n                }\n            }\n        }\n        try {\n            for (var _g = __values(this.listeners), _h = _g.next(); !_h.done; _h = _g.next()) {\n                var listener = _h.value;\n                listener(state, state.event);\n            }\n        } catch (e_3_1) {\n            e_3 = { error: e_3_1 };\n        } finally {\n            try {\n                if (_h && !_h.done && (_b = _g.return)) _b.call(_g);\n            } finally {\n                if (e_3) throw e_3.error;\n            }\n        }\n        try {\n            for (var _j = __values(this.contextListeners), _k = _j.next(); !_k.done; _k = _j.next()) {\n                var contextListener = _k.value;\n                contextListener(this.state.context, this.state.history ? this.state.history.context : undefined);\n            }\n        } catch (e_4_1) {\n            e_4 = { error: e_4_1 };\n        } finally {\n            try {\n                if (_k && !_k.done && (_c = _j.return)) _c.call(_j);\n            } finally {\n                if (e_4) throw e_4.error;\n            }\n        }\n        if (this.state.tree && this.state.tree.done) {\n            // get donedata\n            var doneData = this.state.tree.getDoneData(this.state.context, Object(_actions__WEBPACK_IMPORTED_MODULE_3__[\"toEventObject\"])(event));\n            try {\n                for (var _l = __values(this.doneListeners), _m = _l.next(); !_m.done; _m = _l.next()) {\n                    var listener = _m.value;\n                    listener(Object(_actions__WEBPACK_IMPORTED_MODULE_3__[\"doneInvoke\"])(this.id, doneData));\n                }\n            } catch (e_5_1) {\n                e_5 = { error: e_5_1 };\n            } finally {\n                try {\n                    if (_m && !_m.done && (_d = _l.return)) _d.call(_l);\n                } finally {\n                    if (e_5) throw e_5.error;\n                }\n            }\n            this.stop();\n        }\n    };\n    /*\n     * Adds a listener that is notified whenever a state transition happens. The listener is called with\n     * the next state and the event object that caused the state transition.\n     *\n     * @param listener The state listener\n     */\n    Interpreter.prototype.onTransition = function (listener) {\n        this.listeners.add(listener);\n        return this;\n    };\n    Interpreter.prototype.subscribe = function (nextListener,\n    // @ts-ignore\n    errorListener, completeListener) {\n        var _this = this;\n        if (nextListener) {\n            this.onTransition(nextListener);\n        }\n        if (completeListener) {\n            this.onDone(completeListener);\n        }\n        return {\n            unsubscribe: function () {\n                nextListener && _this.listeners.delete(nextListener);\n                completeListener && _this.doneListeners.delete(completeListener);\n            }\n        };\n    };\n    /**\n     * Adds an event listener that is notified whenever an event is sent to the running interpreter.\n     * @param listener The event listener\n     */\n    Interpreter.prototype.onEvent = function (listener) {\n        this.eventListeners.add(listener);\n        return this;\n    };\n    /**\n     * Adds an event listener that is notified whenever a `send` event occurs.\n     * @param listener The event listener\n     */\n    Interpreter.prototype.onSend = function (listener) {\n        this.sendListeners.add(listener);\n        return this;\n    };\n    /**\n     * Adds a context listener that is notified whenever the state context changes.\n     * @param listener The context listener\n     */\n    Interpreter.prototype.onChange = function (listener) {\n        this.contextListeners.add(listener);\n        return this;\n    };\n    /**\n     * Adds a listener that is notified when the machine is stopped.\n     * @param listener The listener\n     */\n    Interpreter.prototype.onStop = function (listener) {\n        this.stopListeners.add(listener);\n        return this;\n    };\n    /**\n     * Adds a state listener that is notified when the statechart has reached its final state.\n     * @param listener The state listener\n     */\n    Interpreter.prototype.onDone = function (listener) {\n        this.doneListeners.add(listener);\n        return this;\n    };\n    /**\n     * Removes a listener.\n     * @param listener The listener to remove\n     */\n    Interpreter.prototype.off = function (listener) {\n        this.listeners.delete(listener);\n        this.eventListeners.delete(listener);\n        this.sendListeners.delete(listener);\n        this.stopListeners.delete(listener);\n        this.doneListeners.delete(listener);\n        this.contextListeners.delete(listener);\n        return this;\n    };\n    /**\n     * Starts the interpreter from the given state, or the initial state.\n     * @param initialState The state to start the statechart from\n     */\n    Interpreter.prototype.start = function (initialState) {\n        var _this = this;\n        if (this.initialized) {\n            // Do not restart the service if it is already started\n            return this;\n        }\n        this.initialized = true;\n        var resolvedState = withServiceScope(this, function () {\n            return initialState === undefined ? _this.machine.initialState : initialState instanceof _State__WEBPACK_IMPORTED_MODULE_1__[\"State\"] ? _this.machine.resolveState(initialState) : _this.machine.resolveState(_State__WEBPACK_IMPORTED_MODULE_1__[\"State\"].from(initialState));\n        });\n        if (this.options.devTools) {\n            this.attachDev();\n        }\n        this.scheduler.initialize(function () {\n            _this.update(resolvedState, { type: _actionTypes__WEBPACK_IMPORTED_MODULE_2__[\"init\"] });\n        });\n        return this;\n    };\n    /**\n     * Stops the interpreter and unsubscribe all listeners.\n     *\n     * This will also notify the `onStop` listeners.\n     */\n    Interpreter.prototype.stop = function () {\n        var e_6, _a, e_7, _b, e_8, _c, e_9, _d, e_10, _e;\n        try {\n            for (var _f = __values(this.listeners), _g = _f.next(); !_g.done; _g = _f.next()) {\n                var listener = _g.value;\n                this.listeners.delete(listener);\n            }\n        } catch (e_6_1) {\n            e_6 = { error: e_6_1 };\n        } finally {\n            try {\n                if (_g && !_g.done && (_a = _f.return)) _a.call(_f);\n            } finally {\n                if (e_6) throw e_6.error;\n            }\n        }\n        try {\n            for (var _h = __values(this.stopListeners), _j = _h.next(); !_j.done; _j = _h.next()) {\n                var listener = _j.value;\n                // call listener, then remove\n                listener();\n                this.stopListeners.delete(listener);\n            }\n        } catch (e_7_1) {\n            e_7 = { error: e_7_1 };\n        } finally {\n            try {\n                if (_j && !_j.done && (_b = _h.return)) _b.call(_h);\n            } finally {\n                if (e_7) throw e_7.error;\n            }\n        }\n        try {\n            for (var _k = __values(this.contextListeners), _l = _k.next(); !_l.done; _l = _k.next()) {\n                var listener = _l.value;\n                this.contextListeners.delete(listener);\n            }\n        } catch (e_8_1) {\n            e_8 = { error: e_8_1 };\n        } finally {\n            try {\n                if (_l && !_l.done && (_c = _k.return)) _c.call(_k);\n            } finally {\n                if (e_8) throw e_8.error;\n            }\n        }\n        try {\n            for (var _m = __values(this.doneListeners), _o = _m.next(); !_o.done; _o = _m.next()) {\n                var listener = _o.value;\n                this.doneListeners.delete(listener);\n            }\n        } catch (e_9_1) {\n            e_9 = { error: e_9_1 };\n        } finally {\n            try {\n                if (_o && !_o.done && (_d = _m.return)) _d.call(_m);\n            } finally {\n                if (e_9) throw e_9.error;\n            }\n        }\n        // Stop all children\n        this.children.forEach(function (child) {\n            if (Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"isFunction\"])(child.stop)) {\n                child.stop();\n            }\n        });\n        try {\n            // Cancel all delayed events\n            for (var _p = __values(Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"keys\"])(this.delayedEventsMap)), _q = _p.next(); !_q.done; _q = _p.next()) {\n                var key = _q.value;\n                this.clock.clearTimeout(this.delayedEventsMap[key]);\n            }\n        } catch (e_10_1) {\n            e_10 = { error: e_10_1 };\n        } finally {\n            try {\n                if (_q && !_q.done && (_e = _p.return)) _e.call(_p);\n            } finally {\n                if (e_10) throw e_10.error;\n            }\n        }\n        this.initialized = false;\n        return this;\n    };\n    Interpreter.prototype.batch = function (events) {\n        var _this = this;\n        if (!this.initialized && this.options.deferEvents) {\n            // tslint:disable-next-line:no-console\n            if (!_environment__WEBPACK_IMPORTED_MODULE_4__[\"IS_PRODUCTION\"]) {\n                Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"warn\"])(false, events.length + \" event(s) were sent to uninitialized service \\\"\" + this.machine.id + \"\\\" and are deferred. Make sure .start() is called for this service.\\nEvent: \" + JSON.stringify(event));\n            }\n        } else if (!this.initialized) {\n            throw new Error(\n            // tslint:disable-next-line:max-line-length\n            events.length + \" event(s) were sent to uninitialized service \\\"\" + this.machine.id + \"\\\". Make sure .start() is called for this service, or set { deferEvents: true } in the service options.\");\n        }\n        this.scheduler.schedule(function () {\n            var e_11, _a, _b;\n            var nextState = _this.state;\n            try {\n                for (var events_1 = __values(events), events_1_1 = events_1.next(); !events_1_1.done; events_1_1 = events_1.next()) {\n                    var event_1 = events_1_1.value;\n                    var changed = nextState.changed;\n                    var eventObject = Object(_actions__WEBPACK_IMPORTED_MODULE_3__[\"toEventObject\"])(event_1);\n                    var actions = nextState.actions.map(function (a) {\n                        return Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"bindActionToState\"])(a, nextState);\n                    });\n                    nextState = _this.machine.transition(nextState, eventObject);\n                    (_b = nextState.actions).unshift.apply(_b, __spread(actions));\n                    nextState.changed = nextState.changed || !!changed;\n                    _this.forward(eventObject);\n                }\n            } catch (e_11_1) {\n                e_11 = { error: e_11_1 };\n            } finally {\n                try {\n                    if (events_1_1 && !events_1_1.done && (_a = events_1.return)) _a.call(events_1);\n                } finally {\n                    if (e_11) throw e_11.error;\n                }\n            }\n            _this.update(nextState, Object(_actions__WEBPACK_IMPORTED_MODULE_3__[\"toEventObject\"])(events[events.length - 1]));\n        });\n    };\n    /**\n     * Returns a send function bound to this interpreter instance.\n     *\n     * @param event The event to be sent by the sender.\n     */\n    Interpreter.prototype.sender = function (event) {\n        return this.send.bind(this, event);\n    };\n    /**\n     * Returns the next state given the interpreter's current state and the event.\n     *\n     * This is a pure method that does _not_ update the interpreter's state.\n     *\n     * @param event The event to determine the next state\n     */\n    Interpreter.prototype.nextState = function (event) {\n        var _this = this;\n        var eventObject = Object(_actions__WEBPACK_IMPORTED_MODULE_3__[\"toEventObject\"])(event);\n        if (eventObject.type.indexOf(_actionTypes__WEBPACK_IMPORTED_MODULE_2__[\"errorPlatform\"]) === 0 && !this.state.nextEvents.some(function (nextEvent) {\n            return nextEvent.indexOf(_actionTypes__WEBPACK_IMPORTED_MODULE_2__[\"errorPlatform\"]) === 0;\n        })) {\n            throw eventObject.data;\n        }\n        var nextState = withServiceScope(this, function () {\n            return _this.machine.transition(_this.state, eventObject, _this.state.context);\n        });\n        return nextState;\n    };\n    Interpreter.prototype.forward = function (event) {\n        var e_12, _a;\n        try {\n            for (var _b = __values(this.forwardTo), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var id = _c.value;\n                var child = this.children.get(id);\n                if (!child) {\n                    throw new Error(\"Unable to forward event '\" + event + \"' from interpreter '\" + this.id + \"' to nonexistant child '\" + id + \"'.\");\n                }\n                child.send(event);\n            }\n        } catch (e_12_1) {\n            e_12 = { error: e_12_1 };\n        } finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            } finally {\n                if (e_12) throw e_12.error;\n            }\n        }\n    };\n    Interpreter.prototype.defer = function (sendAction) {\n        var _this = this;\n        var delay = sendAction.delay;\n        if (Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"isString\"])(delay)) {\n            if (!this.machine.options.delays || this.machine.options.delays[delay] === undefined) {\n                // tslint:disable-next-line:no-console\n                if (!_environment__WEBPACK_IMPORTED_MODULE_4__[\"IS_PRODUCTION\"]) {\n                    Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"warn\"])(false,\n                    // tslint:disable-next-line:max-line-length\n                    \"No delay reference for delay expression '\" + delay + \"' was found on machine '\" + this.machine.id + \"' on service '\" + this.id + \"'.\");\n                }\n                // Do not send anything\n                return;\n            } else {\n                var delayExpr = this.machine.options.delays[delay];\n                delay = typeof delayExpr === 'number' ? delayExpr : delayExpr(this.state.context, this.state.event);\n            }\n        }\n        this.delayedEventsMap[sendAction.id] = this.clock.setTimeout(function () {\n            if (sendAction.to) {\n                _this.sendTo(sendAction.event, sendAction.to);\n            } else {\n                _this.send(sendAction.event);\n            }\n        }, delay || 0);\n    };\n    Interpreter.prototype.cancel = function (sendId) {\n        this.clock.clearTimeout(this.delayedEventsMap[sendId]);\n        delete this.delayedEventsMap[sendId];\n    };\n    Interpreter.prototype.exec = function (action, context, event, actionFunctionMap) {\n        var actionOrExec = Object(_actions__WEBPACK_IMPORTED_MODULE_3__[\"getActionFunction\"])(action.type, actionFunctionMap) || action.exec;\n        var exec = Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"isFunction\"])(actionOrExec) ? actionOrExec : actionOrExec ? actionOrExec.exec : action.exec;\n        if (exec) {\n            // @ts-ignore (TODO: fix for TypeDoc)\n            return exec(context, event, { action: action, state: this.state });\n        }\n        switch (action.type) {\n            case _actionTypes__WEBPACK_IMPORTED_MODULE_2__[\"send\"]:\n                var sendAction = action;\n                if (sendAction.delay) {\n                    this.defer(sendAction);\n                    return;\n                } else {\n                    if (sendAction.to) {\n                        this.sendTo(sendAction.event, sendAction.to);\n                    } else {\n                        this.send(sendAction.event);\n                    }\n                }\n                break;\n            case _actionTypes__WEBPACK_IMPORTED_MODULE_2__[\"cancel\"]:\n                this.cancel(action.sendId);\n                break;\n            case _actionTypes__WEBPACK_IMPORTED_MODULE_2__[\"start\"]:\n                {\n                    var activity = action.activity;\n                    // If the activity will be stopped right after it's started\n                    // (such as in transient states)\n                    // don't bother starting the activity.\n                    if (!this.state.activities[activity.type]) {\n                        break;\n                    }\n                    // Invoked services\n                    if (activity.type === _types__WEBPACK_IMPORTED_MODULE_0__[\"ActionTypes\"].Invoke) {\n                        var serviceCreator = this.machine.options.services ? this.machine.options.services[activity.src] : undefined;\n                        var id = activity.id,\n                            data = activity.data;\n                        if (!_environment__WEBPACK_IMPORTED_MODULE_4__[\"IS_PRODUCTION\"]) {\n                            Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"warn\"])(!('forward' in activity),\n                            // tslint:disable-next-line:max-line-length\n                            \"`forward` property is deprecated (found in invocation of '\" + activity.src + \"' in in machine '\" + this.machine.id + \"'). \" + \"Please use `autoForward` instead.\");\n                        }\n                        var autoForward = 'autoForward' in activity ? activity.autoForward : !!activity.forward;\n                        if (!serviceCreator) {\n                            // tslint:disable-next-line:no-console\n                            if (!_environment__WEBPACK_IMPORTED_MODULE_4__[\"IS_PRODUCTION\"]) {\n                                Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"warn\"])(false, \"No service found for invocation '\" + activity.src + \"' in machine '\" + this.machine.id + \"'.\");\n                            }\n                            return;\n                        }\n                        var source = Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"isFunction\"])(serviceCreator) ? serviceCreator(context, event) : serviceCreator;\n                        if (Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"isPromiseLike\"])(source)) {\n                            this.spawnPromise(Promise.resolve(source), id);\n                        } else if (Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"isFunction\"])(source)) {\n                            this.spawnCallback(source, id);\n                        } else if (Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"isObservable\"])(source)) {\n                            this.spawnObservable(source, id);\n                        } else if (Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"isMachine\"])(source)) {\n                            // TODO: try/catch here\n                            this.spawnMachine(data ? source.withContext(Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"mapContext\"])(data, context, event)) : source, {\n                                id: id,\n                                autoForward: autoForward\n                            });\n                        } else {\n                            // service is string\n                        }\n                    } else {\n                        this.spawnActivity(activity);\n                    }\n                    break;\n                }\n            case _actionTypes__WEBPACK_IMPORTED_MODULE_2__[\"stop\"]:\n                {\n                    this.stopChild(action.activity.id);\n                    break;\n                }\n            case _actionTypes__WEBPACK_IMPORTED_MODULE_2__[\"log\"]:\n                var expr = action.expr ? action.expr(context, event) : undefined;\n                if (action.label) {\n                    this.logger(action.label, expr);\n                } else {\n                    this.logger(expr);\n                }\n                break;\n            default:\n                if (!_environment__WEBPACK_IMPORTED_MODULE_4__[\"IS_PRODUCTION\"]) {\n                    Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"warn\"])(false, \"No implementation found for action type '\" + action.type + \"'\");\n                }\n                break;\n        }\n        return undefined;\n    };\n    Interpreter.prototype.stopChild = function (childId) {\n        var child = this.children.get(childId);\n        if (!child) {\n            return;\n        }\n        this.children.delete(childId);\n        this.forwardTo.delete(childId);\n        if (Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"isFunction\"])(child.stop)) {\n            child.stop();\n        }\n    };\n    Interpreter.prototype.spawn = function (entity, name, options) {\n        if (Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"isPromiseLike\"])(entity)) {\n            return this.spawnPromise(Promise.resolve(entity), name);\n        } else if (Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"isFunction\"])(entity)) {\n            return this.spawnCallback(entity, name);\n        } else if (Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"isObservable\"])(entity)) {\n            return this.spawnObservable(entity, name);\n        } else if (Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"isMachine\"])(entity)) {\n            return this.spawnMachine(entity, __assign({}, options, { id: name }));\n        } else {\n            throw new Error(\"Unable to spawn entity \\\"\" + name + \"\\\" of type \\\"\" + typeof entity + \"\\\".\");\n        }\n    };\n    Interpreter.prototype.spawnMachine = function (machine, options) {\n        var _this = this;\n        if (options === void 0) {\n            options = {};\n        }\n        var childService = new Interpreter(machine, __assign({}, this.options, { parent: this, id: options.id || machine.id }));\n        var resolvedOptions = __assign({}, DEFAULT_SPAWN_OPTIONS, options);\n        if (resolvedOptions.sync) {\n            childService.onTransition(function (state) {\n                _this.send(_actionTypes__WEBPACK_IMPORTED_MODULE_2__[\"update\"], { state: state, id: childService.id });\n            });\n        }\n        childService.onDone(function (doneEvent) {\n            _this.send(doneEvent);\n        }).start();\n        var actor = childService;\n        // const actor = {\n        //   id: childService.id,\n        //   send: childService.send,\n        //   state: childService.state,\n        //   subscribe: childService.subscribe,\n        //   toJSON() {\n        //     return { id: childService.id };\n        //   }\n        // } as Actor<State<TChildContext, TChildEvents>>;\n        this.children.set(childService.id, actor);\n        if (resolvedOptions.autoForward) {\n            this.forwardTo.add(childService.id);\n        }\n        return actor;\n    };\n    Interpreter.prototype.spawnPromise = function (promise, id) {\n        var _this = this;\n        var canceled = false;\n        promise.then(function (response) {\n            if (!canceled) {\n                _this.send(Object(_actions__WEBPACK_IMPORTED_MODULE_3__[\"doneInvoke\"])(id, response));\n            }\n        }, function (errorData) {\n            if (!canceled) {\n                var errorEvent = Object(_actions__WEBPACK_IMPORTED_MODULE_3__[\"error\"])(id, errorData);\n                try {\n                    // Send \"error.execution\" to this (parent).\n                    _this.send(errorEvent);\n                } catch (error) {\n                    _this.reportUnhandledExceptionOnInvocation(errorData, error, id);\n                    if (_this.devTools) {\n                        _this.devTools.send(errorEvent, _this.state);\n                    }\n                    if (_this.machine.strict) {\n                        // it would be better to always stop the state machine if unhandled\n                        // exception/promise rejection happens but because we don't want to\n                        // break existing code so enforce it on strict mode only especially so\n                        // because documentation says that onError is optional\n                        _this.stop();\n                    }\n                }\n            }\n        });\n        var actor = {\n            id: id,\n            send: function () {\n                return void 0;\n            },\n            subscribe: function (next, handleError, complete) {\n                var unsubscribed = false;\n                promise.then(function (response) {\n                    if (unsubscribed) {\n                        return;\n                    }\n                    next && next(response);\n                    if (unsubscribed) {\n                        return;\n                    }\n                    complete && complete();\n                }, function (err) {\n                    if (unsubscribed) {\n                        return;\n                    }\n                    handleError(err);\n                });\n                return {\n                    unsubscribe: function () {\n                        return unsubscribed = true;\n                    }\n                };\n            },\n            stop: function () {\n                canceled = true;\n            },\n            toJSON: function () {\n                return { id: id };\n            }\n        };\n        this.children.set(id, actor);\n        return actor;\n    };\n    Interpreter.prototype.spawnCallback = function (callback, id) {\n        var _this = this;\n        var canceled = false;\n        var receive = function (e) {\n            if (canceled) {\n                return;\n            }\n            _this.send(e);\n        };\n        var listeners = new Set();\n        var callbackStop;\n        try {\n            callbackStop = callback(receive, function (newListener) {\n                listeners.add(newListener);\n            });\n        } catch (err) {\n            this.send(Object(_actions__WEBPACK_IMPORTED_MODULE_3__[\"error\"])(id, err));\n        }\n        if (Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"isPromiseLike\"])(callbackStop)) {\n            // it turned out to be an async function, can't reliably check this before calling `callback`\n            // because transpiled async functions are not recognizable\n            return this.spawnPromise(callbackStop, id);\n        }\n        var actor = {\n            id: id,\n            send: function (event) {\n                return listeners.forEach(function (listener) {\n                    return listener(event);\n                });\n            },\n            subscribe: function (next) {\n                listeners.add(next);\n                return {\n                    unsubscribe: function () {\n                        listeners.delete(next);\n                    }\n                };\n            },\n            stop: function () {\n                canceled = true;\n                if (Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"isFunction\"])(callbackStop)) {\n                    callbackStop();\n                }\n            },\n            toJSON: function () {\n                return { id: id };\n            }\n        };\n        this.children.set(id, actor);\n        return actor;\n    };\n    Interpreter.prototype.spawnObservable = function (source, id) {\n        var _this = this;\n        var subscription = source.subscribe(function (value) {\n            _this.send(value);\n        }, function (err) {\n            _this.send(Object(_actions__WEBPACK_IMPORTED_MODULE_3__[\"error\"])(id, err));\n        }, function () {\n            _this.send(Object(_actions__WEBPACK_IMPORTED_MODULE_3__[\"doneInvoke\"])(id));\n        });\n        var actor = {\n            id: id,\n            send: function () {\n                return void 0;\n            },\n            subscribe: function (next, handleError, complete) {\n                return source.subscribe(next, handleError, complete);\n            },\n            stop: function () {\n                return subscription.unsubscribe();\n            },\n            toJSON: function () {\n                return { id: id };\n            }\n        };\n        this.children.set(id, actor);\n        return actor;\n    };\n    Interpreter.prototype.spawnActivity = function (activity) {\n        var implementation = this.machine.options && this.machine.options.activities ? this.machine.options.activities[activity.type] : undefined;\n        if (!implementation) {\n            // tslint:disable-next-line:no-console\n            if (!_environment__WEBPACK_IMPORTED_MODULE_4__[\"IS_PRODUCTION\"]) {\n                Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"warn\"])(false, \"No implementation found for activity '\" + activity.type + \"'\");\n            }\n            return;\n        }\n        // Start implementation\n        var dispose = implementation(this.state.context, activity);\n        this.spawnEffect(activity.id, dispose);\n    };\n    Interpreter.prototype.spawnEffect = function (id, dispose) {\n        this.children.set(id, {\n            id: id,\n            send: function () {\n                return void 0;\n            },\n            subscribe: function () {\n                return { unsubscribe: function () {\n                        return void 0;\n                    } };\n            },\n            stop: dispose || undefined,\n            toJSON: function () {\n                return { id: id };\n            }\n        });\n    };\n    Interpreter.prototype.reportUnhandledExceptionOnInvocation = function (originalError, currentError, id) {\n        if (!_environment__WEBPACK_IMPORTED_MODULE_4__[\"IS_PRODUCTION\"]) {\n            var originalStackTrace = originalError.stack ? \" Stacktrace was '\" + originalError.stack + \"'\" : '';\n            if (originalError === currentError) {\n                // tslint:disable-next-line:no-console\n                console.error(\"Missing onError handler for invocation '\" + id + \"', error was '\" + originalError + \"'.\" + originalStackTrace);\n            } else {\n                var stackTrace = currentError.stack ? \" Stacktrace was '\" + currentError.stack + \"'\" : '';\n                // tslint:disable-next-line:no-console\n                console.error(\"Missing onError handler and/or unhandled exception/promise rejection for invocation '\" + id + \"'. \" + (\"Original error: '\" + originalError + \"'. \" + originalStackTrace + \" Current error is '\" + currentError + \"'.\" + stackTrace));\n            }\n        }\n    };\n    Interpreter.prototype.attachDev = function () {\n        if (this.options.devTools && typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION__) {\n            var devToolsOptions = typeof this.options.devTools === 'object' ? this.options.devTools : undefined;\n            this.devTools = window.__REDUX_DEVTOOLS_EXTENSION__.connect(__assign({ name: this.id, autoPause: true, stateSanitizer: function (state) {\n                    return {\n                        value: state.value,\n                        context: state.context,\n                        actions: state.actions\n                    };\n                } }, devToolsOptions, { features: __assign({ jump: false, skip: false }, devToolsOptions ? devToolsOptions.features : undefined) }));\n            this.devTools.init(this.state);\n        }\n    };\n    Interpreter.prototype.toJSON = function () {\n        return {\n            id: this.id\n        };\n    };\n    /**\n     * The default interpreter options:\n     *\n     * - `clock` uses the global `setTimeout` and `clearTimeout` functions\n     * - `logger` uses the global `console.log()` method\n     */\n    Interpreter.defaultOptions = /*#__PURE__*/function (global) {\n        return {\n            execute: true,\n            deferEvents: true,\n            clock: {\n                setTimeout: function (fn, ms) {\n                    return global.setTimeout.call(null, fn, ms);\n                },\n                clearTimeout: function (id) {\n                    return global.clearTimeout.call(null, id);\n                }\n            },\n            logger: global.console.log.bind(console),\n            devTools: false\n        };\n    }(typeof window === 'undefined' ? global : window);\n    Interpreter.interpret = interpret;\n    return Interpreter;\n}();\n\nvar createNullActor = function (name) {\n    if (name === void 0) {\n        name = 'null';\n    }\n    return {\n        id: name,\n        send: function () {\n            return void 0;\n        },\n        subscribe: function () {\n            // tslint:disable-next-line:no-empty\n            return { unsubscribe: function () {} };\n        },\n        toJSON: function () {\n            return { id: name };\n        }\n    };\n};\nvar resolveSpawnOptions = function (nameOrOptions) {\n    if (Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"isString\"])(nameOrOptions)) {\n        return __assign({}, DEFAULT_SPAWN_OPTIONS, { name: nameOrOptions });\n    }\n    return __assign({}, DEFAULT_SPAWN_OPTIONS, { name: Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"uniqueId\"])() }, nameOrOptions);\n};\nfunction spawn(entity, nameOrOptions) {\n    var resolvedOptions = resolveSpawnOptions(nameOrOptions);\n    return withServiceScope(undefined, function (service) {\n        if (!_environment__WEBPACK_IMPORTED_MODULE_4__[\"IS_PRODUCTION\"]) {\n            Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"warn\"])(!!service, \"Attempted to spawn an Actor (ID: \\\"\" + (Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"isMachine\"])(entity) ? entity.id : 'undefined') + \"\\\") outside of a service. This will have no effect.\");\n        }\n        if (service) {\n            return service.spawn(entity, resolvedOptions.name, resolvedOptions);\n        } else {\n            return createNullActor(resolvedOptions.name);\n        }\n    });\n}\n/**\n * Creates a new Interpreter instance for the given machine with the provided options, if any.\n *\n * @param machine The machine to interpret\n * @param options Interpreter options\n */\nfunction interpret(machine, options) {\n    var interpreter = new Interpreter(machine, options);\n    return interpreter;\n}\n//# sourceMappingURL=interpreter.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/xstate/es/interpreter.js?");

/***/ }),

/***/ "./node_modules/xstate/es/mapState.js":
/*!********************************************!*\
  !*** ./node_modules/xstate/es/mapState.js ***!
  \********************************************/
/*! exports provided: mapState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mapState\", function() { return mapState; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./node_modules/xstate/es/utils.js\");\nvar __values = undefined && undefined.__values || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n        i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\n\nfunction mapState(stateMap, stateId) {\n    var e_1, _a;\n    var foundStateId;\n    try {\n        for (var _b = __values(Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(stateMap)), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var mappedStateId = _c.value;\n            if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"matchesState\"])(mappedStateId, stateId) && (!foundStateId || stateId.length > foundStateId.length)) {\n                foundStateId = mappedStateId;\n            }\n        }\n    } catch (e_1_1) {\n        e_1 = { error: e_1_1 };\n    } finally {\n        try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n            if (e_1) throw e_1.error;\n        }\n    }\n    return stateMap[foundStateId];\n}\n//# sourceMappingURL=mapState.js.map\n\n//# sourceURL=webpack:///./node_modules/xstate/es/mapState.js?");

/***/ }),

/***/ "./node_modules/xstate/es/match.js":
/*!*****************************************!*\
  !*** ./node_modules/xstate/es/match.js ***!
  \*****************************************/
/*! exports provided: matchState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"matchState\", function() { return matchState; });\n/* harmony import */ var _State__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./State */ \"./node_modules/xstate/es/State.js\");\nvar __values = undefined && undefined.__values || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n        i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nvar __read = undefined && undefined.__read || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o),\n        r,\n        ar = [],\n        e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    } catch (error) {\n        e = { error: error };\n    } finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        } finally {\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n};\n\nfunction matchState(state, patterns, defaultValue) {\n    var e_1, _a;\n    var resolvedState = _State__WEBPACK_IMPORTED_MODULE_0__[\"State\"].from(state, state instanceof _State__WEBPACK_IMPORTED_MODULE_0__[\"State\"] ? state.context : undefined);\n    try {\n        for (var patterns_1 = __values(patterns), patterns_1_1 = patterns_1.next(); !patterns_1_1.done; patterns_1_1 = patterns_1.next()) {\n            var _b = __read(patterns_1_1.value, 2),\n                stateValue = _b[0],\n                getValue = _b[1];\n            if (resolvedState.matches(stateValue)) {\n                return getValue(resolvedState);\n            }\n        }\n    } catch (e_1_1) {\n        e_1 = { error: e_1_1 };\n    } finally {\n        try {\n            if (patterns_1_1 && !patterns_1_1.done && (_a = patterns_1.return)) _a.call(patterns_1);\n        } finally {\n            if (e_1) throw e_1.error;\n        }\n    }\n    return defaultValue(resolvedState);\n}\n//# sourceMappingURL=match.js.map\n\n//# sourceURL=webpack:///./node_modules/xstate/es/match.js?");

/***/ }),

/***/ "./node_modules/xstate/es/scheduler.js":
/*!*********************************************!*\
  !*** ./node_modules/xstate/es/scheduler.js ***!
  \*********************************************/
/*! exports provided: Scheduler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Scheduler\", function() { return Scheduler; });\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar defaultOptions = {\n    deferEvents: false\n};\nvar Scheduler = /** @class */ /*#__PURE__*/function () {\n    function Scheduler(options) {\n        this.processingEvent = false;\n        this.queue = [];\n        this.initialized = false;\n        this.options = __assign({}, defaultOptions, options);\n    }\n    Scheduler.prototype.initialize = function (callback) {\n        this.initialized = true;\n        if (callback) {\n            if (!this.options.deferEvents) {\n                this.schedule(callback);\n                return;\n            }\n            this.process(callback);\n        }\n        this.flushEvents();\n    };\n    Scheduler.prototype.schedule = function (task) {\n        if (!this.initialized || this.processingEvent) {\n            this.queue.push(task);\n            return;\n        }\n        if (this.queue.length !== 0) {\n            throw new Error('Event queue should be empty when it is not processing events');\n        }\n        this.process(task);\n        this.flushEvents();\n    };\n    Scheduler.prototype.flushEvents = function () {\n        var nextCallback = this.queue.shift();\n        while (nextCallback) {\n            this.process(nextCallback);\n            nextCallback = this.queue.shift();\n        }\n    };\n    Scheduler.prototype.process = function (callback) {\n        this.processingEvent = true;\n        try {\n            callback();\n        } catch (e) {\n            // there is no use to keep the future events\n            // as the situation is not anymore the same\n            this.queue = [];\n            throw e;\n        } finally {\n            this.processingEvent = false;\n        }\n    };\n    return Scheduler;\n}();\n\n//# sourceMappingURL=scheduler.js.map\n\n//# sourceURL=webpack:///./node_modules/xstate/es/scheduler.js?");

/***/ }),

/***/ "./node_modules/xstate/es/stateUtils.js":
/*!**********************************************!*\
  !*** ./node_modules/xstate/es/stateUtils.js ***!
  \**********************************************/
/*! exports provided: getConfiguration, getAdjList, getValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getConfiguration\", function() { return getConfiguration; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getAdjList\", function() { return getAdjList; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getValue\", function() { return getValue; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./node_modules/xstate/es/utils.js\");\nvar __values = undefined && undefined.__values || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n        i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\n\nfunction getChildren(stateNode) {\n    return Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(stateNode.states).map(function (key) {\n        return stateNode.states[key];\n    });\n}\nfunction getConfiguration(prevStateNodes, stateNodes) {\n    var e_1, _a, e_2, _b, e_3, _c;\n    var prevConfiguration = new Set(prevStateNodes);\n    var prevAdjList = getAdjList(prevConfiguration);\n    var configuration = new Set(stateNodes);\n    try {\n        // add all ancestors\n        for (var configuration_1 = __values(configuration), configuration_1_1 = configuration_1.next(); !configuration_1_1.done; configuration_1_1 = configuration_1.next()) {\n            var s = configuration_1_1.value;\n            var m = s.parent;\n            while (m && !configuration.has(m)) {\n                configuration.add(m);\n                m = m.parent;\n            }\n        }\n    } catch (e_1_1) {\n        e_1 = { error: e_1_1 };\n    } finally {\n        try {\n            if (configuration_1_1 && !configuration_1_1.done && (_a = configuration_1.return)) _a.call(configuration_1);\n        } finally {\n            if (e_1) throw e_1.error;\n        }\n    }\n    var adjList = getAdjList(configuration);\n    try {\n        // console.log('KEYS:', [...adjList.keys()].map(k => k.id));\n        // add descendants\n        for (var configuration_2 = __values(configuration), configuration_2_1 = configuration_2.next(); !configuration_2_1.done; configuration_2_1 = configuration_2.next()) {\n            var s = configuration_2_1.value;\n            if (s.type === 'compound' && (!adjList.get(s) || !adjList.get(s).length)) {\n                if (prevAdjList.get(s)) {\n                    prevAdjList.get(s).forEach(function (sn) {\n                        return configuration.add(sn);\n                    });\n                } else {\n                    s.initialStateNodes.forEach(function (sn) {\n                        return configuration.add(sn);\n                    });\n                }\n            } else {\n                if (s.type === 'parallel') {\n                    try {\n                        for (var _d = __values(getChildren(s)), _e = _d.next(); !_e.done; _e = _d.next()) {\n                            var child = _e.value;\n                            if (!configuration.has(child)) {\n                                configuration.add(child);\n                                if (prevAdjList.get(child)) {\n                                    prevAdjList.get(child).forEach(function (sn) {\n                                        return configuration.add(sn);\n                                    });\n                                } else {\n                                    child.initialStateNodes.forEach(function (sn) {\n                                        return configuration.add(sn);\n                                    });\n                                }\n                            }\n                        }\n                    } catch (e_3_1) {\n                        e_3 = { error: e_3_1 };\n                    } finally {\n                        try {\n                            if (_e && !_e.done && (_c = _d.return)) _c.call(_d);\n                        } finally {\n                            if (e_3) throw e_3.error;\n                        }\n                    }\n                }\n            }\n        }\n    } catch (e_2_1) {\n        e_2 = { error: e_2_1 };\n    } finally {\n        try {\n            if (configuration_2_1 && !configuration_2_1.done && (_b = configuration_2.return)) _b.call(configuration_2);\n        } finally {\n            if (e_2) throw e_2.error;\n        }\n    }\n    return configuration;\n}\nfunction getValueFromAdj(baseNode, adjList) {\n    var stateValue = {};\n    var childStateNodes = adjList.get(baseNode);\n    if (!childStateNodes) {\n        return {}; // todo: fix?\n    }\n    if (baseNode.type === 'compound') {\n        if (childStateNodes[0]) {\n            if (childStateNodes[0].type === 'atomic') {\n                return childStateNodes[0].key;\n            }\n        } else {\n            return {};\n        }\n    }\n    childStateNodes.forEach(function (csn) {\n        stateValue[csn.key] = getValueFromAdj(csn, adjList);\n    });\n    return stateValue;\n}\nfunction getAdjList(configuration) {\n    var e_4, _a;\n    var adjList = new Map();\n    try {\n        for (var configuration_3 = __values(configuration), configuration_3_1 = configuration_3.next(); !configuration_3_1.done; configuration_3_1 = configuration_3.next()) {\n            var s = configuration_3_1.value;\n            if (!adjList.has(s)) {\n                adjList.set(s, []);\n            }\n            if (s.parent) {\n                if (!adjList.has(s.parent)) {\n                    adjList.set(s.parent, []);\n                }\n                adjList.get(s.parent).push(s);\n            }\n        }\n    } catch (e_4_1) {\n        e_4 = { error: e_4_1 };\n    } finally {\n        try {\n            if (configuration_3_1 && !configuration_3_1.done && (_a = configuration_3.return)) _a.call(configuration_3);\n        } finally {\n            if (e_4) throw e_4.error;\n        }\n    }\n    // console.log(\n    //   [...adjList.keys()].map(key => [key.id, adjList.get(key)!.map(sn => sn.id)])\n    // );\n    return adjList;\n}\nfunction getValue(rootNode, configuration) {\n    var config = getConfiguration([rootNode], configuration);\n    return getValueFromAdj(rootNode, getAdjList(config));\n}\n//# sourceMappingURL=stateUtils.js.map\n\n//# sourceURL=webpack:///./node_modules/xstate/es/stateUtils.js?");

/***/ }),

/***/ "./node_modules/xstate/es/types.js":
/*!*****************************************!*\
  !*** ./node_modules/xstate/es/types.js ***!
  \*****************************************/
/*! exports provided: ActionTypes, SpecialTargets */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ActionTypes\", function() { return ActionTypes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SpecialTargets\", function() { return SpecialTargets; });\nvar ActionTypes;\n(function (ActionTypes) {\n    ActionTypes[\"Start\"] = \"xstate.start\";\n    ActionTypes[\"Stop\"] = \"xstate.stop\";\n    ActionTypes[\"Raise\"] = \"xstate.raise\";\n    ActionTypes[\"Send\"] = \"xstate.send\";\n    ActionTypes[\"Cancel\"] = \"xstate.cancel\";\n    ActionTypes[\"NullEvent\"] = \"\";\n    ActionTypes[\"Assign\"] = \"xstate.assign\";\n    ActionTypes[\"After\"] = \"xstate.after\";\n    ActionTypes[\"DoneState\"] = \"done.state\";\n    ActionTypes[\"DoneInvoke\"] = \"done.invoke\";\n    ActionTypes[\"Log\"] = \"xstate.log\";\n    ActionTypes[\"Init\"] = \"xstate.init\";\n    ActionTypes[\"Invoke\"] = \"xstate.invoke\";\n    ActionTypes[\"ErrorExecution\"] = \"error.execution\";\n    ActionTypes[\"ErrorCommunication\"] = \"error.communication\";\n    ActionTypes[\"ErrorPlatform\"] = \"error.platform\";\n    ActionTypes[\"Update\"] = \"xstate.update\";\n    ActionTypes[\"Pure\"] = \"xstate.pure\";\n})(ActionTypes || (ActionTypes = {}));\nvar SpecialTargets;\n(function (SpecialTargets) {\n    SpecialTargets[\"Parent\"] = \"#_parent\";\n    SpecialTargets[\"Internal\"] = \"#_internal\";\n})(SpecialTargets || (SpecialTargets = {}));\n//# sourceMappingURL=types.js.map\n\n//# sourceURL=webpack:///./node_modules/xstate/es/types.js?");

/***/ }),

/***/ "./node_modules/xstate/es/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/xstate/es/utils.js ***!
  \*****************************************/
/*! exports provided: keys, matchesState, getEventType, getActionType, toStatePath, toStateValue, pathToStateValue, mapValues, mapFilterValues, path, nestedPath, toStatePaths, pathsToStateValue, flatten, toArray, mapContext, isBuiltInEvent, isPromiseLike, partition, updateHistoryStates, updateHistoryValue, updateContext, bindActionToState, warn, isArray, isFunction, isString, toGuard, isObservable, isMachine, uniqueId */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keys\", function() { return keys; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"matchesState\", function() { return matchesState; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getEventType\", function() { return getEventType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getActionType\", function() { return getActionType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toStatePath\", function() { return toStatePath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toStateValue\", function() { return toStateValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pathToStateValue\", function() { return pathToStateValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mapValues\", function() { return mapValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mapFilterValues\", function() { return mapFilterValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"path\", function() { return path; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"nestedPath\", function() { return nestedPath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toStatePaths\", function() { return toStatePaths; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pathsToStateValue\", function() { return pathsToStateValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"flatten\", function() { return flatten; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toArray\", function() { return toArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mapContext\", function() { return mapContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isBuiltInEvent\", function() { return isBuiltInEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isPromiseLike\", function() { return isPromiseLike; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"partition\", function() { return partition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updateHistoryStates\", function() { return updateHistoryStates; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updateHistoryValue\", function() { return updateHistoryValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updateContext\", function() { return updateContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bindActionToState\", function() { return bindActionToState; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"warn\", function() { return warn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isArray\", function() { return isArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isFunction\", function() { return isFunction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isString\", function() { return isString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toGuard\", function() { return toGuard; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isObservable\", function() { return isObservable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isMachine\", function() { return isMachine; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"uniqueId\", function() { return uniqueId; });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./node_modules/xstate/es/types.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ \"./node_modules/xstate/es/constants.js\");\n/* harmony import */ var _environment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./environment */ \"./node_modules/xstate/es/environment.js\");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __values = undefined && undefined.__values || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n        i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nvar __read = undefined && undefined.__read || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o),\n        r,\n        ar = [],\n        e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    } catch (error) {\n        e = { error: error };\n    } finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        } finally {\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n};\nvar __spread = undefined && undefined.__spread || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\n\n\n\nfunction isState(state) {\n    if (isString(state)) {\n        return false;\n    }\n    return 'value' in state && 'tree' in state && 'history' in state;\n}\nfunction keys(value) {\n    return Object.keys(value);\n}\nfunction matchesState(parentStateId, childStateId, delimiter) {\n    if (delimiter === void 0) {\n        delimiter = _constants__WEBPACK_IMPORTED_MODULE_1__[\"STATE_DELIMITER\"];\n    }\n    var parentStateValue = toStateValue(parentStateId, delimiter);\n    var childStateValue = toStateValue(childStateId, delimiter);\n    if (isString(childStateValue)) {\n        if (isString(parentStateValue)) {\n            return childStateValue === parentStateValue;\n        }\n        // Parent more specific than child\n        return false;\n    }\n    if (isString(parentStateValue)) {\n        return parentStateValue in childStateValue;\n    }\n    return keys(parentStateValue).every(function (key) {\n        if (!(key in childStateValue)) {\n            return false;\n        }\n        return matchesState(parentStateValue[key], childStateValue[key]);\n    });\n}\nfunction getEventType(event) {\n    try {\n        return isString(event) || typeof event === 'number' ? \"\" + event : event.type;\n    } catch (e) {\n        throw new Error('Events must be strings or objects with a string event.type property.');\n    }\n}\nfunction getActionType(action) {\n    try {\n        return isString(action) || typeof action === 'number' ? \"\" + action : isFunction(action) ? action.name : action.type;\n    } catch (e) {\n        throw new Error('Actions must be strings or objects with a string action.type property.');\n    }\n}\nfunction toStatePath(stateId, delimiter) {\n    try {\n        if (isArray(stateId)) {\n            return stateId;\n        }\n        return stateId.toString().split(delimiter);\n    } catch (e) {\n        throw new Error(\"'\" + stateId + \"' is not a valid state path.\");\n    }\n}\nfunction toStateValue(stateValue, delimiter) {\n    if (isState(stateValue)) {\n        return stateValue.value;\n    }\n    if (isArray(stateValue)) {\n        return pathToStateValue(stateValue);\n    }\n    if (typeof stateValue !== 'string' && !isState(stateValue)) {\n        return stateValue;\n    }\n    var statePath = toStatePath(stateValue, delimiter);\n    return pathToStateValue(statePath);\n}\nfunction pathToStateValue(statePath) {\n    if (statePath.length === 1) {\n        return statePath[0];\n    }\n    var value = {};\n    var marker = value;\n    for (var i = 0; i < statePath.length - 1; i++) {\n        if (i === statePath.length - 2) {\n            marker[statePath[i]] = statePath[i + 1];\n        } else {\n            marker[statePath[i]] = {};\n            marker = marker[statePath[i]];\n        }\n    }\n    return value;\n}\nfunction mapValues(collection, iteratee) {\n    var result = {};\n    var collectionKeys = keys(collection);\n    for (var i = 0; i < collectionKeys.length; i++) {\n        var key = collectionKeys[i];\n        result[key] = iteratee(collection[key], key, collection, i);\n    }\n    return result;\n}\nfunction mapFilterValues(collection, iteratee, predicate) {\n    var e_1, _a;\n    var result = {};\n    try {\n        for (var _b = __values(keys(collection)), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var key = _c.value;\n            var item = collection[key];\n            if (!predicate(item)) {\n                continue;\n            }\n            result[key] = iteratee(item, key, collection);\n        }\n    } catch (e_1_1) {\n        e_1 = { error: e_1_1 };\n    } finally {\n        try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n            if (e_1) throw e_1.error;\n        }\n    }\n    return result;\n}\n/**\n * Retrieves a value at the given path.\n * @param props The deep path to the prop of the desired value\n */\nvar path = function (props) {\n    return function (object) {\n        var e_2, _a;\n        var result = object;\n        try {\n            for (var props_1 = __values(props), props_1_1 = props_1.next(); !props_1_1.done; props_1_1 = props_1.next()) {\n                var prop = props_1_1.value;\n                result = result[prop];\n            }\n        } catch (e_2_1) {\n            e_2 = { error: e_2_1 };\n        } finally {\n            try {\n                if (props_1_1 && !props_1_1.done && (_a = props_1.return)) _a.call(props_1);\n            } finally {\n                if (e_2) throw e_2.error;\n            }\n        }\n        return result;\n    };\n};\n/**\n * Retrieves a value at the given path via the nested accessor prop.\n * @param props The deep path to the prop of the desired value\n */\nfunction nestedPath(props, accessorProp) {\n    return function (object) {\n        var e_3, _a;\n        var result = object;\n        try {\n            for (var props_2 = __values(props), props_2_1 = props_2.next(); !props_2_1.done; props_2_1 = props_2.next()) {\n                var prop = props_2_1.value;\n                result = result[accessorProp][prop];\n            }\n        } catch (e_3_1) {\n            e_3 = { error: e_3_1 };\n        } finally {\n            try {\n                if (props_2_1 && !props_2_1.done && (_a = props_2.return)) _a.call(props_2);\n            } finally {\n                if (e_3) throw e_3.error;\n            }\n        }\n        return result;\n    };\n}\nfunction toStatePaths(stateValue) {\n    if (!stateValue) {\n        return [[]];\n    }\n    if (isString(stateValue)) {\n        return [[stateValue]];\n    }\n    var result = flatten(keys(stateValue).map(function (key) {\n        var subStateValue = stateValue[key];\n        if (typeof subStateValue !== 'string' && (!subStateValue || !Object.keys(subStateValue).length)) {\n            return [[key]];\n        }\n        return toStatePaths(stateValue[key]).map(function (subPath) {\n            return [key].concat(subPath);\n        });\n    }));\n    return result;\n}\nvar pathsToStateValue = function (paths) {\n    var e_4, _a;\n    var result = {};\n    if (paths && paths.length === 1 && paths[0].length === 1) {\n        return paths[0][0];\n    }\n    try {\n        for (var paths_1 = __values(paths), paths_1_1 = paths_1.next(); !paths_1_1.done; paths_1_1 = paths_1.next()) {\n            var currentPath = paths_1_1.value;\n            var marker = result;\n            // tslint:disable-next-line:prefer-for-of\n            for (var i = 0; i < currentPath.length; i++) {\n                var subPath = currentPath[i];\n                if (i === currentPath.length - 2) {\n                    marker[subPath] = currentPath[i + 1];\n                    break;\n                }\n                marker[subPath] = marker[subPath] || {};\n                marker = marker[subPath];\n            }\n        }\n    } catch (e_4_1) {\n        e_4 = { error: e_4_1 };\n    } finally {\n        try {\n            if (paths_1_1 && !paths_1_1.done && (_a = paths_1.return)) _a.call(paths_1);\n        } finally {\n            if (e_4) throw e_4.error;\n        }\n    }\n    return result;\n};\nfunction flatten(array) {\n    var _a;\n    return (_a = []).concat.apply(_a, __spread(array));\n}\nfunction toArray(value) {\n    if (isArray(value)) {\n        return value;\n    }\n    if (value === undefined) {\n        return [];\n    }\n    return [value];\n}\nfunction mapContext(mapper, context, event) {\n    var e_5, _a;\n    if (isFunction(mapper)) {\n        return mapper(context, event);\n    }\n    var result = {};\n    try {\n        for (var _b = __values(keys(mapper)), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var key = _c.value;\n            var subMapper = mapper[key];\n            if (isFunction(subMapper)) {\n                result[key] = subMapper(context, event);\n            } else {\n                result[key] = subMapper;\n            }\n        }\n    } catch (e_5_1) {\n        e_5 = { error: e_5_1 };\n    } finally {\n        try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n            if (e_5) throw e_5.error;\n        }\n    }\n    return result;\n}\nfunction isBuiltInEvent(eventType) {\n    // check if event is a \"done\" event\n    if (eventType.indexOf(_types__WEBPACK_IMPORTED_MODULE_0__[\"ActionTypes\"].DoneState) === 0 || eventType.indexOf(_types__WEBPACK_IMPORTED_MODULE_0__[\"ActionTypes\"].DoneInvoke) === 0) {\n        return true;\n    }\n    // check if event is an \"error\" event\n    if (eventType === _types__WEBPACK_IMPORTED_MODULE_0__[\"ActionTypes\"].ErrorCommunication || eventType === _types__WEBPACK_IMPORTED_MODULE_0__[\"ActionTypes\"].ErrorExecution || eventType.indexOf(_types__WEBPACK_IMPORTED_MODULE_0__[\"ActionTypes\"].ErrorPlatform) === 0) {\n        return true;\n    }\n    return false;\n}\nfunction isPromiseLike(value) {\n    if (value instanceof Promise) {\n        return true;\n    }\n    // Check if shape matches the Promise/A+ specification for a \"thenable\".\n    if (value !== null && (isFunction(value) || typeof value === 'object') && isFunction(value.then)) {\n        return true;\n    }\n    return false;\n}\nfunction partition(items, predicate) {\n    var e_6, _a;\n    var _b = __read([[], []], 2),\n        truthy = _b[0],\n        falsy = _b[1];\n    try {\n        for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {\n            var item = items_1_1.value;\n            if (predicate(item)) {\n                truthy.push(item);\n            } else {\n                falsy.push(item);\n            }\n        }\n    } catch (e_6_1) {\n        e_6 = { error: e_6_1 };\n    } finally {\n        try {\n            if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);\n        } finally {\n            if (e_6) throw e_6.error;\n        }\n    }\n    return [truthy, falsy];\n}\nfunction updateHistoryStates(hist, stateValue) {\n    return mapValues(hist.states, function (subHist, key) {\n        if (!subHist) {\n            return undefined;\n        }\n        var subStateValue = (isString(stateValue) ? undefined : stateValue[key]) || (subHist ? subHist.current : undefined);\n        if (!subStateValue) {\n            return undefined;\n        }\n        return {\n            current: subStateValue,\n            states: updateHistoryStates(subHist, subStateValue)\n        };\n    });\n}\nfunction updateHistoryValue(hist, stateValue) {\n    return {\n        current: stateValue,\n        states: updateHistoryStates(hist, stateValue)\n    };\n}\nfunction updateContext(context, event, assignActions) {\n    var updatedContext = context ? assignActions.reduce(function (acc, assignAction) {\n        var e_7, _a;\n        var assignment = assignAction.assignment;\n        var partialUpdate = {};\n        if (isFunction(assignment)) {\n            partialUpdate = assignment(acc, event || { type: _types__WEBPACK_IMPORTED_MODULE_0__[\"ActionTypes\"].Init });\n        } else {\n            try {\n                for (var _b = __values(keys(assignment)), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var key = _c.value;\n                    var propAssignment = assignment[key];\n                    partialUpdate[key] = isFunction(propAssignment) ? propAssignment(acc, event) : propAssignment;\n                }\n            } catch (e_7_1) {\n                e_7 = { error: e_7_1 };\n            } finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                } finally {\n                    if (e_7) throw e_7.error;\n                }\n            }\n        }\n        return Object.assign({}, acc, partialUpdate);\n    }, context) : context;\n    return updatedContext;\n}\nfunction bindActionToState(action, state) {\n    var exec = action.exec;\n    var boundAction = __assign({}, action, { exec: exec !== undefined ? function () {\n            return exec(state.context, state.event, {\n                action: action,\n                state: state\n            });\n        } : undefined });\n    return boundAction;\n}\n// tslint:disable-next-line:no-empty\nvar warn = function () {};\nif (!_environment__WEBPACK_IMPORTED_MODULE_2__[\"IS_PRODUCTION\"]) {\n    warn = function (condition, message) {\n        var error = condition instanceof Error ? condition : undefined;\n        if (!error && condition) {\n            return;\n        }\n        if (console !== undefined) {\n            var args = [\"Warning: \" + message];\n            if (error) {\n                args.push(error);\n            }\n            // tslint:disable-next-line:no-console\n            console.warn.apply(console, args);\n        }\n    };\n}\n\nfunction isArray(value) {\n    return Array.isArray(value);\n}\n// tslint:disable-next-line:ban-types\nfunction isFunction(value) {\n    return typeof value === 'function';\n}\nfunction isString(value) {\n    return typeof value === 'string';\n}\n// export function memoizedGetter<T, TP extends { prototype: object }>(\n//   o: TP,\n//   property: string,\n//   getter: () => T\n// ): void {\n//   Object.defineProperty(o.prototype, property, {\n//     get: getter,\n//     enumerable: false,\n//     configurable: false\n//   });\n// }\nfunction toGuard(condition, guardMap) {\n    if (!condition) {\n        return undefined;\n    }\n    if (isString(condition)) {\n        return {\n            type: _constants__WEBPACK_IMPORTED_MODULE_1__[\"DEFAULT_GUARD_TYPE\"],\n            name: condition,\n            predicate: guardMap ? guardMap[condition] : undefined\n        };\n    }\n    if (isFunction(condition)) {\n        return {\n            type: _constants__WEBPACK_IMPORTED_MODULE_1__[\"DEFAULT_GUARD_TYPE\"],\n            name: condition.name,\n            predicate: condition\n        };\n    }\n    return condition;\n}\nfunction isObservable(value) {\n    try {\n        return 'subscribe' in value && isFunction(value.subscribe);\n    } catch (e) {\n        return false;\n    }\n}\nfunction isMachine(value) {\n    try {\n        return '__xstatenode' in value;\n    } catch (e) {\n        return false;\n    }\n}\nvar uniqueId = /*#__PURE__*/function () {\n    var currentId = 0;\n    return function () {\n        currentId++;\n        return currentId.toString(16);\n    };\n}();\n//# sourceMappingURL=utils.js.map\n\n//# sourceURL=webpack:///./node_modules/xstate/es/utils.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xstate */ \"./node_modules/xstate/es/index.js\");\n\n\nconst { raise } = xstate__WEBPACK_IMPORTED_MODULE_0__[\"actions\"];\n// import { keyboardMachine } afrom './spanish-layout.js'\n\nconst bodytag = document.querySelector(\"body\")\n\nconst keyboardStates = {\n\n}\nconst machineConfig = {\n  id: 'keyboard',\n  initial: 'start',\n  context: {\n    lastEvent: null,\n    keysPressed: new Set(),\n    keys: {\n      KeyA: { type: 'char', char: 'a', shift: 'A', quote: '', quoteshift: ''},\n      ShiftLeft: { type: 'shift'},\n      ShiftRight: { type: 'shift'},\n\n    }\n  },\n  states: {\n    start: {\n      initial: 'char',\n      onEntry: [ 'log' ],\n      states: {\n        checking: {},\n        shift: {},\n        quote: {},\n        quoteshift: {},\n        char: {},\n        hist: {\n          type: 'history',\n          target: 'char'\n        }\n      },\n      on: {\n        'keydown': { actions: ['press','highlight', 'resend']},\n        'keyup': { actions: ['release','unhighlight', 'resend']},\n        'shiftkeydown': { target: '.shift'},\n        'shiftkeyup' : { target: '.char'},\n        'quotekeydown': { target: '.quote' },\n        'charkeydown' : { target: '.hist', actions: ['print'] }\n      }\n    }\n  }\n}\n\nconst machineOptions = { \n  actions: {\n    'log': (context, event, actionMeta) => {\n      console.log(\"event type=>\" + event.type + \" code:\" + event.code)\n    },\n    'highlight': (context, event) => {\n      console.log(\"highlight\")\n      // TODO: comprobar que es null\n      let node = document.getElementById(event.code)\n      node.setAttribute(\"class\", \"highlight\")\n    },\n    'unhighlight': (context, event) => {\n      console.log(\"unhighlight\")\n      // TODO: comprobar que es null\n      let node = document.getElementById(event.code)\n      node.setAttribute(\"class\", \"\")\n    },\n    'press': (context, event) => {\n      //debugger\n      console.log(\"press \" + event.code)\n      context.keysPressed.add(event.code)\n      context.lastEvent = event\n    },\n    'release': (context, event) => {\n      console.log(\"release \" + event.code)\n      context.keysPressed.delete(event.code)\n      context.lastEvent = event\n    },\n    'print': (context, event, actionMeta) => {\n      console.log(\"print\")\n      let state = actionMeta.state.value.start\n      let char = context.keys[event.code][state]\n      let node = document.getElementById(\"typing\")\n      node.innerText += char\n    },\n    'resend': //(context, event) => raise({ type: context.keys[event.code].type, code: event.code } ) \n      Object(xstate__WEBPACK_IMPORTED_MODULE_0__[\"send\"])((context, event) => (\n        { type: context.keys[event.code].type + event.type,\n          code: event.code }))\n  },\n  activities: {},\n  guards: {\n    'isChar': (context, event) => {\n      let ischar = context.keys[event.code].type == 'char'\n      console.log(\"is char key?\" + ischar)\n      return ischar\n    },\n    'isShift': (context, event) => {\n      let isshift = context.keys[event.code].type == 'shift'\n      console.log(\"is shift?\" + isshift)\n      return isshift\n    },\n    'noshift': (context, event) => {\n      let shift = false\n      context.keysPressed.forEach(function(key) {\n        if (key.type == 'shift') {\n          shift = true\n        }\n      })\n      return !shift\n    },\n    'isDown': (context, event) => ( context.lastEvent.type === 'keydown' ),\n    'isUp': (context, event) => ( context.lastEvent.type === 'keyup' )\n  },\n  services: {}}\n\n\nconst layout = Object(xstate__WEBPACK_IMPORTED_MODULE_0__[\"Machine\"])(machineConfig, machineOptions)\n\n// Machine instance with internal state\nconst keyboard = Object(xstate__WEBPACK_IMPORTED_MODULE_0__[\"interpret\"])(layout)\n  .onTransition(\n    state => {console.log(state.value) }\n  )\n  .start()\n\nconst loadHandler = function(event) {\n  bodytag.onkeydown = keydownHandler\n  bodytag.onkeyup = keyupHandler\n  //keyboard.send('keydown', {code: 'ShiftRight'})\n  //keyboard.send('keydown', {code: 'KeyA'})\n  //keyboard.send('keyup', {code: 'KeyA'})\n  //keyboard.send('keyup', {code: 'ShiftRight'})\n}\n\nlet keydownHandler = function (event) {\n  keyboard.send(event)\n}\n\nlet keyupHandler = function (event) {\n  keyboard.send(event)\n}\n\nwindow.onload = loadHandler\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ })

/******/ });